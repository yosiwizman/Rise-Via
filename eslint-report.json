[{"filePath":"/workspace/project/Rise-Via/.storybook/main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/.storybook/preview.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/babel.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/metro.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/navigation/AuthNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/navigation/MainTabNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/AccountScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/AgeVerificationScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/CartScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/HomeScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/LoginScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/ProductDetailScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/RegisterScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/ShopScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/StateSelectionScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/screens/WishlistScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/services/api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/stores/useAppStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/stores/useAuthStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/stores/useCartStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/stores/useWishlistStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/types/navigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/mobile/src/types/shared.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/public/env.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/build-validation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/generate-images.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/generate-sitemap.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/import-strains.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/init-database.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/migrate-to-neon.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/security-check.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/tech-debt-reporter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/verify-all-features.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/scripts/verify-features.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/App.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/admin/OrderManager.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/admin/ProductManager.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/analytics/wishlistAnalytics.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/cart.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/Footer.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/Navigation.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/cart/CartSidebar.coverage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/cart/CartSidebar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/forms/ContactForm.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/layout/Footer.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/layout/Header.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/product/ProductGrid.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Accordion.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/AlertDialog.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Avatar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Breadcrumb.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Button.coverage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Button.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Button.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Card.coverage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Card.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Card.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Checkbox.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Dialog.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Form.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Input.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Input.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Label.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Menubar.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Popover.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Progress.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/RadioGroup.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Select.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Sheet.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Sidebar.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Skeleton.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Slider.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Sonner.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Switch.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Table.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Tabs.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Textarea.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Toaster.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Toggle.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/ToggleGroup.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/ui/Tooltip.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/wishlist/WishlistComponents.comprehensive.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/wishlist/WishlistComponents.enhanced.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/components/wishlist/WishlistPage.comprehensive.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/dashboard/WishlistMetricsDashboard.comprehensive.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/dashboard/WishlistMetricsDashboard.enhanced.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/dashboard/WishlistMetricsDashboard.real.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/dashboard/WishlistMetricsDashboard.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/data/products.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/error-boundary.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/hooks/use-mobile.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/hooks/use-toast.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/hooks/useAgeGate.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/hooks/useCart.coverage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/hooks/useCart.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/hooks/useCart.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/hooks/useWishlist.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/lib/utils.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/lib/utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/AccountPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/AdminPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/B2BPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/CareersPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/CheckoutPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/ContactPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/HomePage.coverage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/HomePage.simple.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/HomePage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/LabResultsPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/LearnPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/LegalPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/LoginPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/NotFoundPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/RegisterPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/ShippingPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/pages/ShopPage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/routes.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/activityService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/api.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/authService.coverage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/customerService.comprehensive.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/customerService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/emailService.comprehensive.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/emailService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/priceTracking.comprehensive.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/priceTracking.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/storage.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/wishlistService.comprehensive.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/services/wishlistService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/types/cart.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/types/product.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/types/wishlist.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/array.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/compliance.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/constants.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/constants.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/cookies.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/date.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/errorHandling.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/formatting.coverage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/formatting.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/formatting.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/imageOptimization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/number.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/security.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/stateBlocking.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/string.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/validation.coverage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/validation.simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/utils/validation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/__tests__/wishlist.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/analytics/cartAnalytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/analytics/complianceAnalytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/analytics/customerIntelligence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/analytics/inventoryManagement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/analytics/revenueAnalytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/analytics/wishlistAnalytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/api/analytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/api/webhooks/payments.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/AgeGate.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/AgeVerificationModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/AnalyticsPlaceholder.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":13,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":13,"endColumn":26,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":173,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":173,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/B2B/PurchaseOrderForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ChatBot.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ComplianceDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/CookieConsent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/CouponInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/FloatingChatButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/Footer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/HealthCheck.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/MobileCartButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/MobileOptimizations.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/Navigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/OnboardingWizard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/PaymentMethodSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/PaymentPlaceholder.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/PopupManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/PriceAlertModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ProductCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ProductDetailModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ProductQuickView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ProductReviews.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ProductReviewsIntegration.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ProductWarnings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/QRCodeModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/RecommendationSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/RegistrationSuccess.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/SEO/ProductSEO.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/SEOHead.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/SearchFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ShippingCalculator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ShippingInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/StateBlocker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/StripeCheckout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/TierBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ToastEventHandler.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/AIContentGenerator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/ActivityLogs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/BulkProductUpload.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/ComplianceChecker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/CustomerIntelligenceDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/CustomerList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/DashboardMetrics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/EmailManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/InventoryManagementDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/InventoryManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/LabResultsManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/OrderManager.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/OrderManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/PaymentSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/PopupManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/ProductEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/ProductManager.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/ProductManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/ProductMediaManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/RevenueAnalyticsDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/settings/APISettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/settings/AdminSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/settings/EmailSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/settings/ReportsSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/settings/SecuritySettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/settings/SystemSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/admin/settings/UserRoleSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/cart/CartSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/Button.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/Card.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/Dialog.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/Input.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/OptimizedImage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/accordion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/alert-dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/aspect-ratio.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/badge.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":37,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":37,"endColumn":30,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/breadcrumb.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/button.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":58,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":58,"endColumn":32,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/command.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/context-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/drawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/dropdown-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/form.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":171,"column":3,"nodeType":"Identifier","messageId":"namedExport","endLine":171,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/hover-card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/input-otp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/menubar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/navigation-menu.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":120,"column":3,"nodeType":"Identifier","messageId":"namedExport","endLine":120,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/pagination.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/radio-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/resizable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/sidebar.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":771,"column":3,"nodeType":"Identifier","messageId":"namedExport","endLine":771,"endColumn":13,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/sonner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/table.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/toaster.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/toggle-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/toggle.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":46,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":46,"endColumn":32,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/ui/tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/wishlist/WishlistButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/wishlist/WishlistInitializer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/wishlist/WishlistPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/components/wishlist/WishlistShare.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/config/env.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[425,428],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[425,428],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[450,453],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[450,453],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[562,565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[562,565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[706,709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[706,709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[734,737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[734,737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[849,852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[849,852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/contexts/CustomerContext.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":77,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":77,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/dashboard/WishlistMetricsDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/hooks/use-mobile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/hooks/use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/hooks/useAgeGate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/hooks/useCart.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/hooks/useFlowise.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/hooks/useOnboarding.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/hooks/usePopup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/hooks/useWishlist.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/hooks/useWishlistTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/__mocks__/neon.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_values' is defined but never used.","line":4,"column":67,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":74,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[203,206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[203,206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/advanced-analytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/ai-recommendations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/cloudinary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/customer-segmentation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/email-automation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/inventory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/loyalty-system.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/neon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/payment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/performance-optimization.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":371,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":371,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":555,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":555,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'recordError' is defined but never used.","line":568,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":568,"endColumn":25},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":701,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":701,"endColumn":65,"suggestions":[{"messageId":"addBrackets","fix":{"range":[20429,20680],"text":"{ await CacheManager.set({\n            key: 'health_check',\n            data: { test: true },\n            ttl: 60\n          });\n          const cached = await CacheManager.get('health_check');\n          if (!cached) status = 'degraded';\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":729,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":729,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":814,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":814,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23612,23615],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23612,23615],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":814,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":814,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23622,23625],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23622,23625],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":814,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":814,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23633,23636],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23633,23636],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":836,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":836,"endColumn":21}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Optimization Engine\n * Advanced caching, query optimization, and system performance monitoring\n */\n\nimport { sql } from './neon';\n\nexport interface CacheConfig {\n  key: string;\n  data: unknown;\n  ttl: number; // Time to live in seconds\n  tags?: string[]; // For cache invalidation\n  compression?: boolean;\n}\n\nexport interface PerformanceMetrics {\n  responseTime: number;\n  throughput: number;\n  errorRate: number;\n  cacheHitRate: number;\n  databaseQueryTime: number;\n  memoryUsage: number;\n  cpuUsage: number;\n}\n\nexport interface QueryOptimization {\n  query: string;\n  executionTime: number;\n  rowsExamined: number;\n  rowsReturned: number;\n  indexesUsed: string[];\n  optimizationSuggestions: string[];\n}\n\nexport interface SystemHealth {\n  status: 'healthy' | 'warning' | 'critical';\n  uptime: number;\n  lastHealthCheck: string;\n  services: Array<{\n    name: string;\n    status: 'up' | 'down' | 'degraded';\n    responseTime: number;\n    lastCheck: string;\n  }>;\n  alerts: Array<{\n    level: 'info' | 'warning' | 'error' | 'critical';\n    message: string;\n    timestamp: string;\n    resolved: boolean;\n  }>;\n}\n\n// In-memory cache for high-performance operations\nconst memoryCache = new Map<string, { data: unknown; expires: number; tags: string[] }>();\nconst cacheStats = {\n  hits: 0,\n  misses: 0,\n  sets: 0,\n  deletes: 0\n};\n\n/**\n * Initialize performance optimization tables\n */\nexport async function initializePerformanceOptimizationTables(): Promise<void> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available, skipping performance optimization table initialization');\n      return;\n    }\n\n    // Performance metrics table\n    await sql`\n      CREATE TABLE IF NOT EXISTS performance_metrics (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        metric_name VARCHAR(100) NOT NULL,\n        metric_value DECIMAL(15,4) NOT NULL,\n        metric_unit VARCHAR(20),\n        endpoint VARCHAR(255),\n        user_agent TEXT,\n        timestamp TIMESTAMP DEFAULT NOW(),\n        metadata JSONB DEFAULT '{}'\n      )\n    `;\n\n    // Query performance table\n    await sql`\n      CREATE TABLE IF NOT EXISTS query_performance (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        query_hash VARCHAR(64) NOT NULL,\n        query_text TEXT NOT NULL,\n        execution_time_ms DECIMAL(10,3) NOT NULL,\n        rows_examined INTEGER,\n        rows_returned INTEGER,\n        indexes_used TEXT[],\n        timestamp TIMESTAMP DEFAULT NOW(),\n        optimization_applied BOOLEAN DEFAULT false\n      )\n    `;\n\n    // Cache performance table\n    await sql`\n      CREATE TABLE IF NOT EXISTS cache_performance (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        cache_key VARCHAR(255) NOT NULL,\n        cache_type VARCHAR(50) NOT NULL,\n        operation VARCHAR(20) NOT NULL, -- hit, miss, set, delete\n        response_time_ms DECIMAL(8,3),\n        data_size_bytes INTEGER,\n        timestamp TIMESTAMP DEFAULT NOW()\n      )\n    `;\n\n    // System health checks table\n    await sql`\n      CREATE TABLE IF NOT EXISTS system_health_checks (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        service_name VARCHAR(100) NOT NULL,\n        status VARCHAR(20) NOT NULL,\n        response_time_ms DECIMAL(8,3),\n        error_message TEXT,\n        timestamp TIMESTAMP DEFAULT NOW(),\n        metadata JSONB DEFAULT '{}'\n      )\n    `;\n\n    // Performance alerts table\n    await sql`\n      CREATE TABLE IF NOT EXISTS performance_alerts (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        alert_type VARCHAR(50) NOT NULL,\n        severity VARCHAR(20) NOT NULL,\n        message TEXT NOT NULL,\n        threshold_value DECIMAL(15,4),\n        actual_value DECIMAL(15,4),\n        resolved BOOLEAN DEFAULT false,\n        resolved_at TIMESTAMP,\n        created_at TIMESTAMP DEFAULT NOW()\n      )\n    `;\n\n    // Database cache table (for persistent caching)\n    await sql`\n      CREATE TABLE IF NOT EXISTS database_cache (\n        cache_key VARCHAR(255) PRIMARY KEY,\n        cache_data JSONB NOT NULL,\n        cache_tags TEXT[] DEFAULT '{}',\n        expires_at TIMESTAMP NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW(),\n        accessed_at TIMESTAMP DEFAULT NOW(),\n        access_count INTEGER DEFAULT 1\n      )\n    `;\n\n    // Create indexes for performance\n    await sql`CREATE INDEX IF NOT EXISTS idx_performance_metrics_name_time ON performance_metrics(metric_name, timestamp)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_query_performance_hash ON query_performance(query_hash)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_query_performance_time ON query_performance(execution_time_ms DESC)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_cache_performance_key ON cache_performance(cache_key)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_cache_performance_timestamp ON cache_performance(timestamp)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_system_health_service ON system_health_checks(service_name, timestamp)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_performance_alerts_type ON performance_alerts(alert_type, created_at)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_database_cache_expires ON database_cache(expires_at)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_database_cache_tags ON database_cache USING GIN(cache_tags)`;\n\n    console.log('✅ Performance optimization tables initialized successfully');\n  } catch (error) {\n    console.error('❌ Failed to initialize performance optimization tables:', error);\n  }\n}\n\n/**\n * Multi-layer cache system\n */\nexport class CacheManager {\n  /**\n   * Get data from cache (memory first, then database)\n   */\n  static async get<T>(key: string): Promise<T | null> {\n    const startTime = Date.now();\n    \n    try {\n      // Check memory cache first\n      const memoryResult = memoryCache.get(key);\n      if (memoryResult && memoryResult.expires > Date.now()) {\n        cacheStats.hits++;\n        await this.recordCacheOperation(key, 'memory', 'hit', Date.now() - startTime);\n        return memoryResult.data as T;\n      }\n\n      // Check database cache\n      if (sql) {\n        const dbResult = await sql`\n          SELECT cache_data, expires_at FROM database_cache \n          WHERE cache_key = ${key} AND expires_at > NOW()\n        ` as Array<{ cache_data: T; expires_at: string }>;\n\n        if (dbResult.length > 0) {\n          cacheStats.hits++;\n          \n          // Update access statistics\n          await sql`\n            UPDATE database_cache \n            SET accessed_at = NOW(), access_count = access_count + 1\n            WHERE cache_key = ${key}\n          `;\n\n          // Also store in memory cache for faster future access\n          memoryCache.set(key, {\n            data: dbResult[0].cache_data,\n            expires: new Date(dbResult[0].expires_at).getTime(),\n            tags: []\n          });\n\n          await this.recordCacheOperation(key, 'database', 'hit', Date.now() - startTime);\n          return dbResult[0].cache_data;\n        }\n      }\n\n      cacheStats.misses++;\n      await this.recordCacheOperation(key, 'memory', 'miss', Date.now() - startTime);\n      return null;\n    } catch (error) {\n      console.error('Cache get error:', error);\n      cacheStats.misses++;\n      return null;\n    }\n  }\n\n  /**\n   * Set data in cache (both memory and database)\n   */\n  static async set(config: CacheConfig): Promise<void> {\n    const startTime = Date.now();\n    \n    try {\n      const expires = Date.now() + (config.ttl * 1000);\n      const expiresDate = new Date(expires);\n\n      // Set in memory cache\n      memoryCache.set(config.key, {\n        data: config.data,\n        expires,\n        tags: config.tags || []\n      });\n\n      // Set in database cache for persistence\n      if (sql) {\n        await sql`\n          INSERT INTO database_cache (cache_key, cache_data, cache_tags, expires_at)\n          VALUES (${config.key}, ${JSON.stringify(config.data)}, ${config.tags || []}, ${expiresDate.toISOString()})\n          ON CONFLICT (cache_key) DO UPDATE SET\n            cache_data = EXCLUDED.cache_data,\n            cache_tags = EXCLUDED.cache_tags,\n            expires_at = EXCLUDED.expires_at,\n            accessed_at = NOW(),\n            access_count = database_cache.access_count + 1\n        `;\n      }\n\n      cacheStats.sets++;\n      await this.recordCacheOperation(config.key, 'memory', 'set', Date.now() - startTime, JSON.stringify(config.data).length);\n    } catch (error) {\n      console.error('Cache set error:', error);\n    }\n  }\n\n  /**\n   * Delete from cache\n   */\n  static async delete(key: string): Promise<void> {\n    const startTime = Date.now();\n    \n    try {\n      // Delete from memory cache\n      memoryCache.delete(key);\n\n      // Delete from database cache\n      if (sql) {\n        await sql`DELETE FROM database_cache WHERE cache_key = ${key}`;\n      }\n\n      cacheStats.deletes++;\n      await this.recordCacheOperation(key, 'memory', 'delete', Date.now() - startTime);\n    } catch (error) {\n      console.error('Cache delete error:', error);\n    }\n  }\n\n  /**\n   * Invalidate cache by tags\n   */\n  static async invalidateByTags(tags: string[]): Promise<void> {\n    try {\n      // Clear from memory cache\n      for (const [key, value] of memoryCache.entries()) {\n        if (value.tags.some(tag => tags.includes(tag))) {\n          memoryCache.delete(key);\n        }\n      }\n\n      // Clear from database cache\n      if (sql) {\n        await sql`\n          DELETE FROM database_cache \n          WHERE cache_tags && ${tags}\n        `;\n      }\n    } catch (error) {\n      console.error('Cache invalidation error:', error);\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  static getCacheStats(): typeof cacheStats & { hitRate: number; memorySize: number } {\n    const total = cacheStats.hits + cacheStats.misses;\n    const hitRate = total > 0 ? (cacheStats.hits / total) * 100 : 0;\n    \n    return {\n      ...cacheStats,\n      hitRate: Math.round(hitRate * 100) / 100,\n      memorySize: memoryCache.size\n    };\n  }\n\n  /**\n   * Clean up expired cache entries\n   */\n  static async cleanup(): Promise<void> {\n    try {\n      const now = Date.now();\n      \n      // Clean memory cache\n      for (const [key, value] of memoryCache.entries()) {\n        if (value.expires <= now) {\n          memoryCache.delete(key);\n        }\n      }\n\n      // Clean database cache\n      if (sql) {\n        const deleted = await sql`\n          DELETE FROM database_cache WHERE expires_at < NOW()\n        `;\n        console.log(`Cleaned up ${deleted.length} expired cache entries`);\n      }\n    } catch (error) {\n      console.error('Cache cleanup error:', error);\n    }\n  }\n\n  /**\n   * Record cache operation for analytics\n   */\n  private static async recordCacheOperation(\n    key: string,\n    cacheType: string,\n    operation: string,\n    responseTime: number,\n    dataSize?: number\n  ): Promise<void> {\n    try {\n      if (sql) {\n        await sql`\n          INSERT INTO cache_performance (cache_key, cache_type, operation, response_time_ms, data_size_bytes)\n          VALUES (${key}, ${cacheType}, ${operation}, ${responseTime}, ${dataSize || null})\n        `;\n      }\n    } catch (error) {\n      // Don't log cache recording errors to avoid recursion\n    }\n  }\n}\n\n/**\n * Query performance monitoring\n */\nexport class QueryOptimizer {\n  /**\n   * Monitor query performance\n   */\n  static async monitorQuery<T>(\n    queryText: string,\n    queryFunction: () => Promise<T>\n  ): Promise<T> {\n    const startTime = Date.now();\n    const queryHash = this.hashQuery(queryText);\n    \n    try {\n      const result = await queryFunction();\n      const executionTime = Date.now() - startTime;\n      \n      // Record query performance\n      await this.recordQueryPerformance(queryHash, queryText, executionTime, result);\n      \n      // Check for slow queries\n      if (executionTime > 1000) { // Queries taking more than 1 second\n        await this.createPerformanceAlert(\n          'slow_query',\n          'warning',\n          `Slow query detected: ${executionTime}ms`,\n          1000,\n          executionTime\n        );\n      }\n      \n      return result;\n    } catch (error) {\n      const executionTime = Date.now() - startTime;\n      await this.recordQueryPerformance(queryHash, queryText, executionTime, null, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get query performance analytics\n   */\n  static async getQueryAnalytics(): Promise<{\n    slowestQueries: QueryOptimization[];\n    averageQueryTime: number;\n    totalQueries: number;\n    optimizationOpportunities: string[];\n  }> {\n    try {\n      if (!sql) {\n        return {\n          slowestQueries: [],\n          averageQueryTime: 0,\n          totalQueries: 0,\n          optimizationOpportunities: []\n        };\n      }\n\n      const slowQueries = await sql`\n        SELECT \n          query_hash,\n          query_text,\n          AVG(execution_time_ms) as avg_execution_time,\n          COUNT(*) as execution_count,\n          MAX(execution_time_ms) as max_execution_time,\n          AVG(rows_examined) as avg_rows_examined,\n          AVG(rows_returned) as avg_rows_returned\n        FROM query_performance\n        WHERE timestamp > NOW() - INTERVAL '24 hours'\n        GROUP BY query_hash, query_text\n        ORDER BY avg_execution_time DESC\n        LIMIT 10\n      ` as Array<{\n        query_hash: string;\n        query_text: string;\n        avg_execution_time: number;\n        execution_count: number;\n        max_execution_time: number;\n        avg_rows_examined: number;\n        avg_rows_returned: number;\n      }>;\n\n      const overallStats = await sql`\n        SELECT \n          AVG(execution_time_ms) as avg_query_time,\n          COUNT(*) as total_queries\n        FROM query_performance\n        WHERE timestamp > NOW() - INTERVAL '24 hours'\n      ` as Array<{ avg_query_time: number; total_queries: number }>;\n\n      const stats = overallStats[0] || { avg_query_time: 0, total_queries: 0 };\n\n      const slowestQueries: QueryOptimization[] = slowQueries.map(q => ({\n        query: q.query_text,\n        executionTime: q.avg_execution_time,\n        rowsExamined: q.avg_rows_examined || 0,\n        rowsReturned: q.avg_rows_returned || 0,\n        indexesUsed: [], // Would need to parse EXPLAIN output\n        optimizationSuggestions: this.generateOptimizationSuggestions(q)\n      }));\n\n      const optimizationOpportunities = [\n        'Add indexes for frequently queried columns',\n        'Consider query result caching for repeated queries',\n        'Optimize JOIN operations with proper indexing',\n        'Use LIMIT clauses for large result sets'\n      ];\n\n      return {\n        slowestQueries,\n        averageQueryTime: Math.round(stats.avg_query_time * 100) / 100,\n        totalQueries: stats.total_queries,\n        optimizationOpportunities\n      };\n    } catch (error) {\n      console.error('Failed to get query analytics:', error);\n      return {\n        slowestQueries: [],\n        averageQueryTime: 0,\n        totalQueries: 0,\n        optimizationOpportunities: []\n      };\n    }\n  }\n\n  /**\n   * Generate optimization suggestions\n   */\n  private static generateOptimizationSuggestions(queryData: {\n    avg_execution_time: number;\n    avg_rows_examined: number;\n    avg_rows_returned: number;\n    query_text: string;\n  }): string[] {\n    const suggestions: string[] = [];\n\n    if (queryData.avg_execution_time > 500) {\n      suggestions.push('Query execution time is high - consider optimization');\n    }\n\n    if (queryData.avg_rows_examined > queryData.avg_rows_returned * 10) {\n      suggestions.push('High rows examined to returned ratio - add selective indexes');\n    }\n\n    if (queryData.query_text.includes('SELECT *')) {\n      suggestions.push('Avoid SELECT * - specify only needed columns');\n    }\n\n    if (queryData.query_text.includes('ORDER BY') && !queryData.query_text.includes('LIMIT')) {\n      suggestions.push('Consider adding LIMIT to ORDER BY queries');\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * Hash query for tracking\n   */\n  private static hashQuery(query: string): string {\n    // Simple hash function for query identification\n    let hash = 0;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(16);\n  }\n\n  /**\n   * Record query performance\n   */\n  private static async recordQueryPerformance(\n    queryHash: string,\n    queryText: string,\n    executionTime: number,\n    result: unknown,\n    error?: Error\n  ): Promise<void> {\n    try {\n      if (sql) {\n        const rowsReturned = Array.isArray(result) ? result.length : (result ? 1 : 0);\n        \n        await sql`\n          INSERT INTO query_performance (\n            query_hash, query_text, execution_time_ms, rows_returned\n          )\n          VALUES (${queryHash}, ${queryText}, ${executionTime}, ${rowsReturned})\n        `;\n      }\n    } catch (recordError) {\n      // Don't log recording errors to avoid recursion\n    }\n  }\n\n  /**\n   * Create performance alert\n   */\n  private static async createPerformanceAlert(\n    alertType: string,\n    severity: string,\n    message: string,\n    threshold: number,\n    actualValue: number\n  ): Promise<void> {\n    try {\n      if (sql) {\n        await sql`\n          INSERT INTO performance_alerts (\n            alert_type, severity, message, threshold_value, actual_value\n          )\n          VALUES (${alertType}, ${severity}, ${message}, ${threshold}, ${actualValue})\n        `;\n      }\n    } catch (error) {\n      console.error('Failed to create performance alert:', error);\n    }\n  }\n}\n\n/**\n * System health monitoring\n */\nexport class HealthMonitor {\n  private static services = [\n    { name: 'database', url: 'internal://database' },\n    { name: 'cache', url: 'internal://cache' },\n    { name: 'email', url: 'internal://email' },\n    { name: 'payment', url: 'internal://payment' }\n  ];\n\n  /**\n   * Perform comprehensive health check\n   */\n  static async performHealthCheck(): Promise<SystemHealth> {\n    const startTime = Date.now();\n    const serviceResults = [];\n    const alerts = [];\n\n    // Check each service\n    for (const service of this.services) {\n      const serviceHealth = await this.checkService(service.name);\n      serviceResults.push(serviceHealth);\n\n      if (serviceHealth.status === 'down') {\n        alerts.push({\n          level: 'critical' as const,\n          message: `Service ${service.name} is down`,\n          timestamp: new Date().toISOString(),\n          resolved: false\n        });\n      } else if (serviceHealth.status === 'degraded') {\n        alerts.push({\n          level: 'warning' as const,\n          message: `Service ${service.name} is degraded`,\n          timestamp: new Date().toISOString(),\n          resolved: false\n        });\n      }\n    }\n\n    // Check system metrics\n    const cacheStats = CacheManager.getCacheStats();\n    if (cacheStats.hitRate < 50) {\n      alerts.push({\n        level: 'warning' as const,\n        message: `Low cache hit rate: ${cacheStats.hitRate}%`,\n        timestamp: new Date().toISOString(),\n        resolved: false\n      });\n    }\n\n    // Determine overall system status\n    const criticalServices = serviceResults.filter(s => s.status === 'down').length;\n    const degradedServices = serviceResults.filter(s => s.status === 'degraded').length;\n    \n    let overallStatus: SystemHealth['status'] = 'healthy';\n    if (criticalServices > 0) {\n      overallStatus = 'critical';\n    } else if (degradedServices > 0) {\n      overallStatus = 'warning';\n    }\n\n    const healthCheck: SystemHealth = {\n      status: overallStatus,\n      uptime: Date.now() - startTime, // Simplified uptime\n      lastHealthCheck: new Date().toISOString(),\n      services: serviceResults,\n      alerts\n    };\n\n    // Record health check\n    await this.recordHealthCheck(healthCheck);\n\n    return healthCheck;\n  }\n\n  /**\n   * Check individual service health\n   */\n  private static async checkService(serviceName: string): Promise<SystemHealth['services'][0]> {\n    const startTime = Date.now();\n    \n    try {\n      let status: 'up' | 'down' | 'degraded' = 'up';\n      \n      // Service-specific health checks\n      switch (serviceName) {\n        case 'database':\n          if (sql) {\n            await sql`SELECT 1`;\n          } else {\n            status = 'down';\n          }\n          break;\n          \n        case 'cache':\n          // Test cache operations\n          await CacheManager.set({\n            key: 'health_check',\n            data: { test: true },\n            ttl: 60\n          });\n          const cached = await CacheManager.get('health_check');\n          if (!cached) status = 'degraded';\n          break;\n          \n        case 'email':\n          // Would check email service connectivity\n          status = 'up'; // Placeholder\n          break;\n          \n        case 'payment':\n          // Would check payment processor connectivity\n          status = 'up'; // Placeholder\n          break;\n      }\n\n      const responseTime = Date.now() - startTime;\n      \n      // Consider slow response as degraded\n      if (responseTime > 2000) {\n        status = 'degraded';\n      }\n\n      return {\n        name: serviceName,\n        status,\n        responseTime,\n        lastCheck: new Date().toISOString()\n      };\n    } catch (error) {\n      return {\n        name: serviceName,\n        status: 'down',\n        responseTime: Date.now() - startTime,\n        lastCheck: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\n   * Record health check results\n   */\n  private static async recordHealthCheck(healthCheck: SystemHealth): Promise<void> {\n    try {\n      if (sql) {\n        for (const service of healthCheck.services) {\n          await sql`\n            INSERT INTO system_health_checks (\n              service_name, status, response_time_ms, metadata\n            )\n            VALUES (\n              ${service.name}, \n              ${service.status}, \n              ${service.responseTime},\n              ${JSON.stringify({ lastCheck: service.lastCheck })}\n            )\n          `;\n        }\n      }\n    } catch (error) {\n      console.error('Failed to record health check:', error);\n    }\n  }\n\n  /**\n   * Get system performance metrics\n   */\n  static async getPerformanceMetrics(): Promise<PerformanceMetrics> {\n    try {\n      const cacheStats = CacheManager.getCacheStats();\n      \n      // Get recent performance data\n      const recentMetrics = await sql`\n        SELECT \n          metric_name,\n          AVG(metric_value) as avg_value\n        FROM performance_metrics\n        WHERE timestamp > NOW() - INTERVAL '1 hour'\n        GROUP BY metric_name\n      ` as Array<{ metric_name: string; avg_value: number }>;\n\n      const metrics: Record<string, number> = {};\n      recentMetrics.forEach(m => {\n        metrics[m.metric_name] = m.avg_value;\n      });\n\n      return {\n        responseTime: metrics.response_time || 0,\n        throughput: metrics.throughput || 0,\n        errorRate: metrics.error_rate || 0,\n        cacheHitRate: cacheStats.hitRate,\n        databaseQueryTime: metrics.db_query_time || 0,\n        memoryUsage: metrics.memory_usage || 0,\n        cpuUsage: metrics.cpu_usage || 0\n      };\n    } catch (error) {\n      console.error('Failed to get performance metrics:', error);\n      return {\n        responseTime: 0,\n        throughput: 0,\n        errorRate: 0,\n        cacheHitRate: 0,\n        databaseQueryTime: 0,\n        memoryUsage: 0,\n        cpuUsage: 0\n      };\n    }\n  }\n}\n\n/**\n * Performance middleware for tracking request metrics\n */\nexport function createPerformanceMiddleware() {\n  return async (req: any, res: any, next: any) => {\n    const startTime = Date.now();\n    \n    // Track request start\n    res.on('finish', async () => {\n      const responseTime = Date.now() - startTime;\n      \n      try {\n        if (sql) {\n          await sql`\n            INSERT INTO performance_metrics (\n              metric_name, metric_value, metric_unit, endpoint, user_agent\n            )\n            VALUES (\n              'response_time', \n              ${responseTime}, \n              'ms', \n              ${req.path || req.url}, \n              ${req.get('User-Agent') || ''}\n            )\n          `;\n        }\n      } catch (error) {\n        // Don't fail request due to metrics recording error\n      }\n    });\n    \n    next();\n  };\n}\n\n/**\n * Automated performance optimization\n */\nexport async function runPerformanceOptimization(): Promise<void> {\n  try {\n    console.log('🚀 Running performance optimization...');\n\n    // Clean up expired cache entries\n    await CacheManager.cleanup();\n    console.log('✅ Cache cleanup completed');\n\n    // Analyze slow queries and suggest optimizations\n    const queryAnalytics = await QueryOptimizer.getQueryAnalytics();\n    if (queryAnalytics.slowestQueries.length > 0) {\n      console.log(`⚠️ Found ${queryAnalytics.slowestQueries.length} slow queries`);\n      queryAnalytics.slowestQueries.forEach(query => {\n        console.log(`- Query taking ${query.executionTime}ms: ${query.optimizationSuggestions.join(', ')}`);\n      });\n    }\n\n    // Perform health check\n    const healthCheck = await HealthMonitor.performHealthCheck();\n    console.log(`✅ System health: ${healthCheck.status}`);\n    \n    if (healthCheck.alerts.length > 0) {\n      console.log(`⚠️ ${healthCheck.alerts.length} alerts found`);\n      healthCheck.alerts.forEach(alert => {\n        console.log(`- ${alert.level.toUpperCase()}: ${alert.message}`);\n      });\n    }\n\n    // Clean up old performance data (keep last 30 days)\n    if (sql) {\n      await sql`DELETE FROM performance_metrics WHERE timestamp < NOW() - INTERVAL '30 days'`;\n      await sql`DELETE FROM query_performance WHERE timestamp < NOW() - INTERVAL '30 days'`;\n      await sql`DELETE FROM cache_performance WHERE timestamp < NOW() - INTERVAL '30 days'`;\n      console.log('✅ Old performance data cleaned up');\n    }\n\n    console.log('✅ Performance optimization completed');\n  } catch (error) {\n    console.error('❌ Performance optimization failed:', error);\n  }\n}\n\n// Initialize performance optimization tables on module load\ninitializePerformanceOptimizationTables();\n\n// Run performance optimization every hour\nsetInterval(runPerformanceOptimization, 60 * 60 * 1000);\n\n// Clean up memory cache every 15 minutes\nsetInterval(() => CacheManager.cleanup(), 15 * 60 * 1000);","usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/promotions.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'promotions' is never reassigned. Use 'const' instead.","line":383,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":383,"endColumn":32,"fix":{"range":[11699,11732],"text":"const promotions: Promotion[] = [];"}},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":515,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":515,"endColumn":66,"suggestions":[{"messageId":"addBrackets","fix":{"range":[15767,16168],"text":"{ const buyQuantity = Math.floor(promotion.discount_value); // X\n        const getQuantity = 1; // Y (simplified to 1)\n        \n        for (const item of applicableItems) {\n          const eligibleSets = Math.floor(item.quantity / buyQuantity);\n          const freeItems = Math.min(eligibleSets * getQuantity, item.quantity);\n          discountAmount += freeItems * item.price;\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":516,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":516,"endColumn":31,"suggestions":[{"messageId":"addBrackets","fix":{"range":[15767,16168],"text":"{ const buyQuantity = Math.floor(promotion.discount_value); // X\n        const getQuantity = 1; // Y (simplified to 1)\n        \n        for (const item of applicableItems) {\n          const eligibleSets = Math.floor(item.quantity / buyQuantity);\n          const freeItems = Math.min(eligibleSets * getQuantity, item.quantity);\n          discountAmount += freeItems * item.price;\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Promotions & Coupon System\n * Advanced promotional campaigns, discount codes, and marketing automation\n */\n\nimport { sql } from './neon';\nimport { triggerEmailAutomation } from './email-automation';\n\nexport interface Promotion {\n  id: string;\n  name: string;\n  description: string;\n  promotion_type: 'percentage' | 'fixed_amount' | 'buy_x_get_y' | 'free_shipping' | 'bundle';\n  discount_value: number;\n  minimum_order_value?: number;\n  maximum_discount?: number;\n  applicable_products?: string[]; // product IDs\n  applicable_categories?: string[];\n  excluded_products?: string[];\n  usage_limit?: number;\n  usage_limit_per_customer?: number;\n  current_usage: number;\n  is_active: boolean;\n  requires_code: boolean;\n  auto_apply: boolean;\n  valid_from: string;\n  valid_until: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface CouponCode {\n  id: string;\n  code: string;\n  promotion_id: string;\n  usage_limit?: number;\n  usage_limit_per_customer?: number;\n  current_usage: number;\n  is_active: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface PromotionUsage {\n  id: string;\n  promotion_id: string;\n  coupon_code_id?: string;\n  customer_id: string;\n  order_id: string;\n  discount_amount: number;\n  used_at: string;\n}\n\nexport interface CartPromotion {\n  promotion: Promotion;\n  coupon_code?: string;\n  discount_amount: number;\n  applicable_items: Array<{\n    product_id: string;\n    quantity: number;\n    original_price: number;\n    discounted_price: number;\n  }>;\n}\n\nexport interface AbandonedCart {\n  id: string;\n  customer_id?: string;\n  session_id: string;\n  email?: string;\n  items: Array<{\n    product_id: string;\n    product_name: string;\n    quantity: number;\n    price: number;\n    image_url?: string;\n  }>;\n  total_value: number;\n  abandoned_at: string;\n  recovery_emails_sent: number;\n  recovered: boolean;\n  recovered_at?: string;\n  recovery_order_id?: string;\n}\n\n/**\n * Initialize promotions tables\n */\nexport async function initializePromotionsTables(): Promise<void> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available, skipping promotions table initialization');\n      return;\n    }\n\n    // Promotions table\n    await sql`\n      CREATE TABLE IF NOT EXISTS promotions (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        name VARCHAR(255) NOT NULL,\n        description TEXT,\n        promotion_type VARCHAR(50) NOT NULL,\n        discount_value DECIMAL(10,2) NOT NULL,\n        minimum_order_value DECIMAL(10,2),\n        maximum_discount DECIMAL(10,2),\n        applicable_products TEXT[],\n        applicable_categories TEXT[],\n        excluded_products TEXT[],\n        usage_limit INTEGER,\n        usage_limit_per_customer INTEGER,\n        current_usage INTEGER DEFAULT 0,\n        is_active BOOLEAN DEFAULT true,\n        requires_code BOOLEAN DEFAULT false,\n        auto_apply BOOLEAN DEFAULT false,\n        valid_from TIMESTAMP NOT NULL,\n        valid_until TIMESTAMP NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW(),\n        updated_at TIMESTAMP DEFAULT NOW()\n      )\n    `;\n\n    // Coupon codes table\n    await sql`\n      CREATE TABLE IF NOT EXISTS coupon_codes (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        code VARCHAR(50) UNIQUE NOT NULL,\n        promotion_id UUID NOT NULL,\n        usage_limit INTEGER,\n        usage_limit_per_customer INTEGER,\n        current_usage INTEGER DEFAULT 0,\n        is_active BOOLEAN DEFAULT true,\n        created_at TIMESTAMP DEFAULT NOW(),\n        updated_at TIMESTAMP DEFAULT NOW()\n      )\n    `;\n\n    // Promotion usage table\n    await sql`\n      CREATE TABLE IF NOT EXISTS promotion_usage (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        promotion_id UUID NOT NULL,\n        coupon_code_id UUID,\n        customer_id UUID NOT NULL,\n        order_id UUID NOT NULL,\n        discount_amount DECIMAL(10,2) NOT NULL,\n        used_at TIMESTAMP DEFAULT NOW()\n      )\n    `;\n\n    // Abandoned carts table\n    await sql`\n      CREATE TABLE IF NOT EXISTS abandoned_carts (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        customer_id UUID,\n        session_id VARCHAR(255) NOT NULL,\n        email VARCHAR(255),\n        items JSONB NOT NULL,\n        total_value DECIMAL(10,2) NOT NULL,\n        abandoned_at TIMESTAMP DEFAULT NOW(),\n        recovery_emails_sent INTEGER DEFAULT 0,\n        recovered BOOLEAN DEFAULT false,\n        recovered_at TIMESTAMP,\n        recovery_order_id UUID\n      )\n    `;\n\n    // Price alerts table (enhanced from inventory)\n    await sql`\n      CREATE TABLE IF NOT EXISTS price_alerts (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        customer_id UUID,\n        email VARCHAR(255) NOT NULL,\n        product_id VARCHAR(255) NOT NULL,\n        product_name VARCHAR(255) NOT NULL,\n        target_price DECIMAL(10,2) NOT NULL,\n        current_price DECIMAL(10,2) NOT NULL,\n        is_active BOOLEAN DEFAULT true,\n        created_at TIMESTAMP DEFAULT NOW(),\n        triggered_at TIMESTAMP,\n        notification_sent BOOLEAN DEFAULT false\n      )\n    `;\n\n    // Create indexes\n    await sql`CREATE INDEX IF NOT EXISTS idx_promotions_active ON promotions(is_active)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_promotions_dates ON promotions(valid_from, valid_until)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_promotions_auto_apply ON promotions(auto_apply)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_coupon_codes_code ON coupon_codes(code)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_coupon_codes_promotion ON coupon_codes(promotion_id)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_promotion_usage_customer ON promotion_usage(customer_id)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_promotion_usage_promotion ON promotion_usage(promotion_id)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_abandoned_carts_email ON abandoned_carts(email)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_abandoned_carts_recovered ON abandoned_carts(recovered)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_price_alerts_product ON price_alerts(product_id)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_price_alerts_active ON price_alerts(is_active)`;\n\n    console.log('✅ Promotions tables initialized successfully');\n  } catch (error) {\n    console.error('❌ Failed to initialize promotions tables:', error);\n  }\n}\n\n/**\n * Create promotion\n */\nexport async function createPromotion(\n  name: string,\n  description: string,\n  promotionType: Promotion['promotion_type'],\n  discountValue: number,\n  validFrom: string,\n  validUntil: string,\n  options: {\n    minimumOrderValue?: number;\n    maximumDiscount?: number;\n    applicableProducts?: string[];\n    applicableCategories?: string[];\n    excludedProducts?: string[];\n    usageLimit?: number;\n    usageLimitPerCustomer?: number;\n    requiresCode?: boolean;\n    autoApply?: boolean;\n  } = {}\n): Promise<Promotion | null> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available');\n      return null;\n    }\n\n    const promotions = await sql`\n      INSERT INTO promotions (\n        name, description, promotion_type, discount_value, valid_from, valid_until,\n        minimum_order_value, maximum_discount, applicable_products, applicable_categories,\n        excluded_products, usage_limit, usage_limit_per_customer, requires_code, auto_apply\n      )\n      VALUES (\n        ${name}, ${description}, ${promotionType}, ${discountValue}, ${validFrom}, ${validUntil},\n        ${options.minimumOrderValue || null}, ${options.maximumDiscount || null},\n        ${options.applicableProducts || []}, ${options.applicableCategories || []},\n        ${options.excludedProducts || []}, ${options.usageLimit || null},\n        ${options.usageLimitPerCustomer || null}, ${options.requiresCode || false},\n        ${options.autoApply || false}\n      )\n      RETURNING *\n    ` as Array<Promotion>;\n\n    return promotions.length > 0 ? promotions[0] : null;\n  } catch (error) {\n    console.error('Failed to create promotion:', error);\n    return null;\n  }\n}\n\n/**\n * Create coupon code\n */\nexport async function createCouponCode(\n  promotionId: string,\n  code: string,\n  options: {\n    usageLimit?: number;\n    usageLimitPerCustomer?: number;\n  } = {}\n): Promise<CouponCode | null> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available');\n      return null;\n    }\n\n    const coupons = await sql`\n      INSERT INTO coupon_codes (promotion_id, code, usage_limit, usage_limit_per_customer)\n      VALUES (${promotionId}, ${code.toUpperCase()}, ${options.usageLimit || null}, ${options.usageLimitPerCustomer || null})\n      RETURNING *\n    ` as Array<CouponCode>;\n\n    return coupons.length > 0 ? coupons[0] : null;\n  } catch (error) {\n    console.error('Failed to create coupon code:', error);\n    return null;\n  }\n}\n\n/**\n * Validate coupon code\n */\nexport async function validateCouponCode(\n  code: string,\n  customerId?: string,\n  cartTotal?: number\n): Promise<{ valid: boolean; promotion?: Promotion; error?: string }> {\n  try {\n    if (!sql) {\n      return { valid: false, error: 'Service temporarily unavailable' };\n    }\n\n    // Get coupon and promotion\n    const coupons = await sql`\n      SELECT cc.*, p.*\n      FROM coupon_codes cc\n      JOIN promotions p ON cc.promotion_id = p.id\n      WHERE cc.code = ${code.toUpperCase()} AND cc.is_active = true AND p.is_active = true\n    ` as Array<CouponCode & Promotion>;\n\n    if (coupons.length === 0) {\n      return { valid: false, error: 'Invalid or expired coupon code' };\n    }\n\n    const coupon = coupons[0];\n\n    // Check validity dates\n    const now = new Date();\n    if (new Date(coupon.valid_from) > now) {\n      return { valid: false, error: 'Coupon is not yet valid' };\n    }\n    if (new Date(coupon.valid_until) < now) {\n      return { valid: false, error: 'Coupon has expired' };\n    }\n\n    // Check usage limits\n    if (coupon.usage_limit && coupon.current_usage >= coupon.usage_limit) {\n      return { valid: false, error: 'Coupon usage limit reached' };\n    }\n\n    // Check per-customer usage limit\n    if (customerId && coupon.usage_limit_per_customer) {\n      const customerUsage = await sql`\n        SELECT COUNT(*) as usage_count\n        FROM promotion_usage\n        WHERE promotion_id = ${coupon.promotion_id} AND customer_id = ${customerId}\n      ` as Array<{ usage_count: number }>;\n\n      if (customerUsage[0]?.usage_count >= coupon.usage_limit_per_customer) {\n        return { valid: false, error: 'You have reached the usage limit for this coupon' };\n      }\n    }\n\n    // Check minimum order value\n    if (cartTotal && coupon.minimum_order_value && cartTotal < coupon.minimum_order_value) {\n      return { \n        valid: false, \n        error: `Minimum order value of $${coupon.minimum_order_value} required` \n      };\n    }\n\n    return { valid: true, promotion: coupon };\n  } catch (error) {\n    console.error('Failed to validate coupon code:', error);\n    return { valid: false, error: 'Failed to validate coupon code' };\n  }\n}\n\n/**\n * Apply promotions to cart\n */\nexport async function applyPromotionsToCart(\n  cartItems: Array<{\n    product_id: string;\n    product_name: string;\n    category: string;\n    quantity: number;\n    price: number;\n  }>,\n  customerId?: string,\n  couponCode?: string\n): Promise<{\n  appliedPromotions: CartPromotion[];\n  totalDiscount: number;\n  finalTotal: number;\n}> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available');\n      return { appliedPromotions: [], totalDiscount: 0, finalTotal: 0 };\n    }\n\n    const appliedPromotions: CartPromotion[] = [];\n    let totalDiscount = 0;\n    const originalTotal = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);\n\n    // Get applicable promotions\n    let promotions: Promotion[] = [];\n\n    if (couponCode) {\n      // Validate and get coupon-based promotion\n      const validation = await validateCouponCode(couponCode, customerId, originalTotal);\n      if (validation.valid && validation.promotion) {\n        promotions.push(validation.promotion);\n      }\n    }\n\n    // Get auto-apply promotions\n    const autoPromotions = await sql`\n      SELECT * FROM promotions \n      WHERE is_active = true \n      AND auto_apply = true \n      AND requires_code = false\n      AND valid_from <= NOW() \n      AND valid_until >= NOW()\n      AND (usage_limit IS NULL OR current_usage < usage_limit)\n    ` as Array<Promotion>;\n\n    promotions.push(...autoPromotions);\n\n    // Apply each promotion\n    for (const promotion of promotions) {\n      const cartPromotion = await calculatePromotionDiscount(promotion, cartItems, customerId);\n      if (cartPromotion && cartPromotion.discount_amount > 0) {\n        appliedPromotions.push(cartPromotion);\n        totalDiscount += cartPromotion.discount_amount;\n      }\n    }\n\n    const finalTotal = Math.max(0, originalTotal - totalDiscount);\n\n    return {\n      appliedPromotions,\n      totalDiscount,\n      finalTotal\n    };\n  } catch (error) {\n    console.error('Failed to apply promotions to cart:', error);\n    return { appliedPromotions: [], totalDiscount: 0, finalTotal: 0 };\n  }\n}\n\n/**\n * Calculate promotion discount for cart\n */\nasync function calculatePromotionDiscount(\n  promotion: Promotion,\n  cartItems: Array<{\n    product_id: string;\n    product_name: string;\n    category: string;\n    quantity: number;\n    price: number;\n  }>,\n  customerId?: string\n): Promise<CartPromotion | null> {\n  try {\n    // Check customer usage limit\n    if (customerId && promotion.usage_limit_per_customer) {\n      const customerUsage = await sql`\n        SELECT COUNT(*) as usage_count\n        FROM promotion_usage\n        WHERE promotion_id = ${promotion.id} AND customer_id = ${customerId}\n      ` as Array<{ usage_count: number }>;\n\n      if (customerUsage[0]?.usage_count >= promotion.usage_limit_per_customer) {\n        return null;\n      }\n    }\n\n    // Filter applicable items\n    const applicableItems = cartItems.filter(item => {\n      // Check if product is excluded\n      if (promotion.excluded_products?.includes(item.product_id)) {\n        return false;\n      }\n\n      // Check if specific products are required\n      if (promotion.applicable_products && promotion.applicable_products.length > 0) {\n        return promotion.applicable_products.includes(item.product_id);\n      }\n\n      // Check if specific categories are required\n      if (promotion.applicable_categories && promotion.applicable_categories.length > 0) {\n        return promotion.applicable_categories.includes(item.category);\n      }\n\n      return true;\n    });\n\n    if (applicableItems.length === 0) {\n      return null;\n    }\n\n    const applicableTotal = applicableItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);\n\n    // Check minimum order value\n    if (promotion.minimum_order_value && applicableTotal < promotion.minimum_order_value) {\n      return null;\n    }\n\n    let discountAmount = 0;\n    const discountedItems = applicableItems.map(item => ({\n      product_id: item.product_id,\n      quantity: item.quantity,\n      original_price: item.price,\n      discounted_price: item.price\n    }));\n\n    // Calculate discount based on promotion type\n    switch (promotion.promotion_type) {\n      case 'percentage':\n        discountAmount = applicableTotal * (promotion.discount_value / 100);\n        if (promotion.maximum_discount) {\n          discountAmount = Math.min(discountAmount, promotion.maximum_discount);\n        }\n        break;\n\n      case 'fixed_amount':\n        discountAmount = Math.min(promotion.discount_value, applicableTotal);\n        break;\n\n      case 'free_shipping':\n        // This would be handled at checkout level\n        discountAmount = 0; // Shipping discount handled separately\n        break;\n\n      case 'buy_x_get_y':\n        // Simplified buy X get Y logic\n        const buyQuantity = Math.floor(promotion.discount_value); // X\n        const getQuantity = 1; // Y (simplified to 1)\n        \n        for (const item of applicableItems) {\n          const eligibleSets = Math.floor(item.quantity / buyQuantity);\n          const freeItems = Math.min(eligibleSets * getQuantity, item.quantity);\n          discountAmount += freeItems * item.price;\n        }\n        break;\n\n      default:\n        return null;\n    }\n\n    if (discountAmount <= 0) {\n      return null;\n    }\n\n    return {\n      promotion,\n      discount_amount: Math.round(discountAmount * 100) / 100,\n      applicable_items: discountedItems\n    };\n  } catch (error) {\n    console.error('Failed to calculate promotion discount:', error);\n    return null;\n  }\n}\n\n/**\n * Record promotion usage\n */\nexport async function recordPromotionUsage(\n  promotionId: string,\n  customerId: string,\n  orderId: string,\n  discountAmount: number,\n  couponCodeId?: string\n): Promise<void> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available, skipping promotion usage recording');\n      return;\n    }\n\n    // Record usage\n    await sql`\n      INSERT INTO promotion_usage (promotion_id, coupon_code_id, customer_id, order_id, discount_amount)\n      VALUES (${promotionId}, ${couponCodeId || null}, ${customerId}, ${orderId}, ${discountAmount})\n    `;\n\n    // Update promotion usage count\n    await sql`\n      UPDATE promotions \n      SET current_usage = current_usage + 1,\n          updated_at = NOW()\n      WHERE id = ${promotionId}\n    `;\n\n    // Update coupon usage count if applicable\n    if (couponCodeId) {\n      await sql`\n        UPDATE coupon_codes \n        SET current_usage = current_usage + 1,\n            updated_at = NOW()\n        WHERE id = ${couponCodeId}\n      `;\n    }\n  } catch (error) {\n    console.error('Failed to record promotion usage:', error);\n  }\n}\n\n/**\n * Track abandoned cart\n */\nexport async function trackAbandonedCart(\n  sessionId: string,\n  cartItems: Array<{\n    product_id: string;\n    product_name: string;\n    quantity: number;\n    price: number;\n    image_url?: string;\n  }>,\n  customerId?: string,\n  email?: string\n): Promise<void> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available, skipping abandoned cart tracking');\n      return;\n    }\n\n    if (cartItems.length === 0) return;\n\n    const totalValue = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);\n\n    // Upsert abandoned cart\n    await sql`\n      INSERT INTO abandoned_carts (customer_id, session_id, email, items, total_value)\n      VALUES (${customerId || null}, ${sessionId}, ${email || null}, ${JSON.stringify(cartItems)}, ${totalValue})\n      ON CONFLICT (session_id) DO UPDATE SET\n        customer_id = EXCLUDED.customer_id,\n        email = EXCLUDED.email,\n        items = EXCLUDED.items,\n        total_value = EXCLUDED.total_value,\n        abandoned_at = NOW()\n    `;\n  } catch (error) {\n    console.error('Failed to track abandoned cart:', error);\n  }\n}\n\n/**\n * Process abandoned cart recovery\n */\nexport async function processAbandonedCartRecovery(): Promise<void> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available, skipping abandoned cart recovery');\n      return;\n    }\n\n    // Get abandoned carts that need recovery emails\n    const abandonedCarts = await sql`\n      SELECT * FROM abandoned_carts \n      WHERE recovered = false \n      AND email IS NOT NULL\n      AND abandoned_at < NOW() - INTERVAL '1 hour'\n      AND recovery_emails_sent < 3\n      AND (\n        (recovery_emails_sent = 0 AND abandoned_at < NOW() - INTERVAL '1 hour') OR\n        (recovery_emails_sent = 1 AND abandoned_at < NOW() - INTERVAL '24 hours') OR\n        (recovery_emails_sent = 2 AND abandoned_at < NOW() - INTERVAL '72 hours')\n      )\n    ` as Array<AbandonedCart>;\n\n    for (const cart of abandonedCarts) {\n      // Create recovery discount code\n      const recoveryCode = `COMEBACK${Date.now().toString(36).toUpperCase()}`;\n      \n      // Create a 10% discount promotion for cart recovery\n      const promotion = await createPromotion(\n        `Cart Recovery - ${cart.id}`,\n        'Special discount for abandoned cart recovery',\n        'percentage',\n        10,\n        new Date().toISOString(),\n        new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days\n        {\n          usageLimit: 1,\n          usageLimitPerCustomer: 1,\n          requiresCode: true\n        }\n      );\n\n      if (promotion) {\n        await createCouponCode(promotion.id, recoveryCode, { usageLimit: 1 });\n      }\n\n      // Send recovery email\n      await triggerEmailAutomation('cart_abandoned', cart.email!, {\n        firstName: 'Valued Customer',\n        cartItems: JSON.stringify(cart.items),\n        cartTotal: cart.total_value.toString(),\n        recoveryCode: recoveryCode,\n        recoveryUrl: `${process.env.VITE_APP_URL || 'https://rise-via.vercel.app'}/cart?recovery=${cart.id}&code=${recoveryCode}`\n      });\n\n      // Update recovery email count\n      await sql`\n        UPDATE abandoned_carts \n        SET recovery_emails_sent = recovery_emails_sent + 1\n        WHERE id = ${cart.id}\n      `;\n    }\n\n    console.log(`Processed ${abandonedCarts.length} abandoned cart recovery emails`);\n  } catch (error) {\n    console.error('Failed to process abandoned cart recovery:', error);\n  }\n}\n\n/**\n * Mark cart as recovered\n */\nexport async function markCartAsRecovered(\n  sessionId: string,\n  orderId: string\n): Promise<void> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available, skipping cart recovery marking');\n      return;\n    }\n\n    await sql`\n      UPDATE abandoned_carts \n      SET recovered = true,\n          recovered_at = NOW(),\n          recovery_order_id = ${orderId}\n      WHERE session_id = ${sessionId}\n    `;\n  } catch (error) {\n    console.error('Failed to mark cart as recovered:', error);\n  }\n}\n\n/**\n * Create price alert\n */\nexport async function createPriceAlert(\n  email: string,\n  productId: string,\n  productName: string,\n  targetPrice: number,\n  currentPrice: number,\n  customerId?: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    if (!sql) {\n      return { success: false, error: 'Service temporarily unavailable' };\n    }\n\n    // Check if alert already exists\n    const existing = await sql`\n      SELECT id FROM price_alerts \n      WHERE email = ${email} AND product_id = ${productId} AND is_active = true\n    `;\n\n    if (existing.length > 0) {\n      return { success: false, error: 'Price alert already exists for this product' };\n    }\n\n    await sql`\n      INSERT INTO price_alerts (customer_id, email, product_id, product_name, target_price, current_price)\n      VALUES (${customerId || null}, ${email}, ${productId}, ${productName}, ${targetPrice}, ${currentPrice})\n    `;\n\n    return { success: true };\n  } catch (error) {\n    console.error('Failed to create price alert:', error);\n    return { success: false, error: 'Failed to create price alert' };\n  }\n}\n\n/**\n * Check and trigger price alerts\n */\nexport async function checkPriceAlerts(): Promise<void> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available, skipping price alerts check');\n      return;\n    }\n\n    // This would typically integrate with your product pricing system\n    // For now, we'll simulate checking against current product prices\n    \n    const alerts = await sql`\n      SELECT pa.*, p.price as current_product_price\n      FROM price_alerts pa\n      LEFT JOIN products p ON pa.product_id = p.id\n      WHERE pa.is_active = true \n      AND pa.notification_sent = false\n      AND p.price <= pa.target_price\n    ` as Array<{\n      id: string;\n      email: string;\n      product_id: string;\n      product_name: string;\n      target_price: number;\n      current_product_price: number;\n    }>;\n\n    for (const alert of alerts) {\n      // Send price alert email\n      await triggerEmailAutomation('price_alert', alert.email, {\n        productName: alert.product_name,\n        targetPrice: alert.target_price.toString(),\n        currentPrice: alert.current_product_price.toString(),\n        productUrl: `${process.env.VITE_APP_URL || 'https://rise-via.vercel.app'}/products/${alert.product_id}`\n      });\n\n      // Mark as notified\n      await sql`\n        UPDATE price_alerts \n        SET notification_sent = true,\n            triggered_at = NOW()\n        WHERE id = ${alert.id}\n      `;\n    }\n\n    console.log(`Triggered ${alerts.length} price alerts`);\n  } catch (error) {\n    console.error('Failed to check price alerts:', error);\n  }\n}\n\n/**\n * Get promotion analytics\n */\nexport async function getPromotionAnalytics(\n  startDate: string,\n  endDate: string\n): Promise<{\n  totalPromotions: number;\n  activePromotions: number;\n  totalDiscountGiven: number;\n  totalUsage: number;\n  topPromotions: Array<{ name: string; usage: number; discount_given: number }>;\n  conversionRate: number;\n}> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available');\n      return {\n        totalPromotions: 0,\n        activePromotions: 0,\n        totalDiscountGiven: 0,\n        totalUsage: 0,\n        topPromotions: [],\n        conversionRate: 0\n      };\n    }\n\n    // Get overall stats\n    const overallStats = await sql`\n      SELECT \n        COUNT(*) as total_promotions,\n        COUNT(CASE WHEN is_active = true THEN 1 END) as active_promotions\n      FROM promotions\n    ` as Array<{ total_promotions: number; active_promotions: number }>;\n\n    // Get usage stats\n    const usageStats = await sql`\n      SELECT \n        COUNT(*) as total_usage,\n        SUM(discount_amount) as total_discount_given\n      FROM promotion_usage\n      WHERE used_at BETWEEN ${startDate} AND ${endDate}\n    ` as Array<{ total_usage: number; total_discount_given: number }>;\n\n    // Get top promotions\n    const topPromotions = await sql`\n      SELECT \n        p.name,\n        COUNT(pu.id) as usage,\n        SUM(pu.discount_amount) as discount_given\n      FROM promotions p\n      LEFT JOIN promotion_usage pu ON p.id = pu.promotion_id\n      WHERE pu.used_at BETWEEN ${startDate} AND ${endDate}\n      GROUP BY p.id, p.name\n      ORDER BY usage DESC\n      LIMIT 10\n    ` as Array<{ name: string; usage: number; discount_given: number }>;\n\n    const stats = overallStats[0] || { total_promotions: 0, active_promotions: 0 };\n    const usage = usageStats[0] || { total_usage: 0, total_discount_given: 0 };\n\n    return {\n      totalPromotions: stats.total_promotions,\n      activePromotions: stats.active_promotions,\n      totalDiscountGiven: usage.total_discount_given || 0,\n      totalUsage: usage.total_usage,\n      topPromotions: topPromotions || [],\n      conversionRate: 0 // Would need more complex calculation\n    };\n  } catch (error) {\n    console.error('Failed to get promotion analytics:', error);\n    return {\n      totalPromotions: 0,\n      activePromotions: 0,\n      totalDiscountGiven: 0,\n      totalUsage: 0,\n      topPromotions: [],\n      conversionRate: 0\n    };\n  }\n}\n\n// Initialize promotions tables on module load\ninitializePromotionsTables();\n\n// Run abandoned cart recovery every hour\nsetInterval(processAbandonedCartRecovery, 60 * 60 * 1000);\n\n// Check price alerts every 6 hours\nsetInterval(checkPriceAlerts, 6 * 60 * 60 * 1000);","usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/third-party-integrations.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1334,1337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1334,1337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1441,1444],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1441,1444],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1517,1520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1517,1520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1607,1610],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1607,1610],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1621,1624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1621,1624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1760,1763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1760,1763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2248,2251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2248,2251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2403,2406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2403,2406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":184,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6928,6931],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6928,6931],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":189,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7050,7053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7050,7053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7265,7268],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7265,7268],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8644,8647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8644,8647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":585,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":585,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19076,19079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19076,19079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":605,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":605,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19824,19827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19824,19827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":619,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":619,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20410,20413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20410,20413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'filters' is defined but never used.","line":639,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":639,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":639,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":639,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21134,21137],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21134,21137],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":639,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":639,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21148,21151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21148,21151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'metadata' is defined but never used.","line":682,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":682,"endColumn":54},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":682,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":682,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22516,22519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22516,22519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Third-Party Integrations Hub\n * Centralized management of external service integrations\n */\n\nimport { sql } from './neon';\n\nexport interface IntegrationConfig {\n  id: string;\n  name: string;\n  type: 'crm' | 'sms' | 'email' | 'analytics' | 'social' | 'payment' | 'shipping' | 'inventory';\n  provider: string;\n  status: 'active' | 'inactive' | 'error' | 'pending';\n  credentials: Record<string, string>;\n  settings: Record<string, unknown>;\n  webhook_url?: string;\n  last_sync?: string;\n  error_message?: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface SyncResult {\n  integration_id: string;\n  sync_type: 'full' | 'incremental' | 'webhook';\n  status: 'success' | 'partial' | 'failed';\n  records_processed: number;\n  records_success: number;\n  records_failed: number;\n  error_details?: string[];\n  started_at: string;\n  completed_at: string;\n}\n\nexport interface WebhookEvent {\n  id: string;\n  integration_id: string;\n  event_type: string;\n  payload: Record<string, unknown>;\n  signature?: string;\n  processed: boolean;\n  processed_at?: string;\n  error_message?: string;\n  retry_count: number;\n  created_at: string;\n}\n\n// CRM Integration (HubSpot, Salesforce, etc.)\nexport interface CRMIntegration {\n  syncCustomers(): Promise<SyncResult>;\n  syncOrders(): Promise<SyncResult>;\n  createContact(customerData: any): Promise<{ success: boolean; id?: string; error?: string }>;\n  updateContact(contactId: string, data: any): Promise<{ success: boolean; error?: string }>;\n  createDeal(dealData: any): Promise<{ success: boolean; id?: string; error?: string }>;\n  getContacts(filters?: any): Promise<any[]>;\n}\n\n// SMS Integration (Twilio, SendGrid, etc.)\nexport interface SMSIntegration {\n  sendSMS(to: string, message: string, metadata?: any): Promise<{ success: boolean; messageId?: string; error?: string }>;\n  sendBulkSMS(recipients: Array<{ phone: string; message: string }>): Promise<SyncResult>;\n  getDeliveryStatus(messageId: string): Promise<{ status: string; delivered_at?: string }>;\n  validatePhoneNumber(phone: string): Promise<{ valid: boolean; formatted?: string }>;\n}\n\n// Social Media Integration (Facebook, Instagram, Twitter)\nexport interface SocialMediaIntegration {\n  postContent(platform: string, content: any): Promise<{ success: boolean; postId?: string; error?: string }>;\n  getAnalytics(platform: string, dateRange: { start: string; end: string }): Promise<any>;\n  syncProducts(platform: string): Promise<SyncResult>;\n  respondToMessage(platform: string, messageId: string, response: string): Promise<{ success: boolean; error?: string }>;\n}\n\n/**\n * Initialize third-party integration tables\n */\nexport async function initializeThirdPartyIntegrationTables(): Promise<void> {\n  try {\n    if (!sql) {\n      console.warn('⚠️ Database not available, skipping third-party integration table initialization');\n      return;\n    }\n\n    // Integration configurations table\n    await sql`\n      CREATE TABLE IF NOT EXISTS integration_configs (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        name VARCHAR(255) NOT NULL,\n        type VARCHAR(50) NOT NULL,\n        provider VARCHAR(100) NOT NULL,\n        status VARCHAR(20) DEFAULT 'inactive',\n        credentials JSONB DEFAULT '{}',\n        settings JSONB DEFAULT '{}',\n        webhook_url TEXT,\n        last_sync TIMESTAMP,\n        error_message TEXT,\n        created_at TIMESTAMP DEFAULT NOW(),\n        updated_at TIMESTAMP DEFAULT NOW()\n      )\n    `;\n\n    // Integration sync history table\n    await sql`\n      CREATE TABLE IF NOT EXISTS integration_sync_history (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        integration_id UUID REFERENCES integration_configs(id) ON DELETE CASCADE,\n        sync_type VARCHAR(20) NOT NULL,\n        status VARCHAR(20) NOT NULL,\n        records_processed INTEGER DEFAULT 0,\n        records_success INTEGER DEFAULT 0,\n        records_failed INTEGER DEFAULT 0,\n        error_details JSONB,\n        started_at TIMESTAMP DEFAULT NOW(),\n        completed_at TIMESTAMP,\n        metadata JSONB DEFAULT '{}'\n      )\n    `;\n\n    // Webhook events table\n    await sql`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        integration_id UUID REFERENCES integration_configs(id) ON DELETE CASCADE,\n        event_type VARCHAR(100) NOT NULL,\n        payload JSONB NOT NULL,\n        signature VARCHAR(255),\n        processed BOOLEAN DEFAULT false,\n        processed_at TIMESTAMP,\n        error_message TEXT,\n        retry_count INTEGER DEFAULT 0,\n        created_at TIMESTAMP DEFAULT NOW()\n      )\n    `;\n\n    // Integration data mapping table\n    await sql`\n      CREATE TABLE IF NOT EXISTS integration_data_mapping (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        integration_id UUID REFERENCES integration_configs(id) ON DELETE CASCADE,\n        local_entity VARCHAR(100) NOT NULL,\n        local_field VARCHAR(100) NOT NULL,\n        external_entity VARCHAR(100) NOT NULL,\n        external_field VARCHAR(100) NOT NULL,\n        transformation_rule JSONB,\n        is_bidirectional BOOLEAN DEFAULT false,\n        created_at TIMESTAMP DEFAULT NOW()\n      )\n    `;\n\n    // API rate limiting table\n    await sql`\n      CREATE TABLE IF NOT EXISTS api_rate_limits (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        integration_id UUID REFERENCES integration_configs(id) ON DELETE CASCADE,\n        endpoint VARCHAR(255) NOT NULL,\n        requests_made INTEGER DEFAULT 0,\n        requests_limit INTEGER NOT NULL,\n        window_start TIMESTAMP DEFAULT NOW(),\n        window_duration_minutes INTEGER DEFAULT 60,\n        last_request TIMESTAMP\n      )\n    `;\n\n    // Create indexes\n    await sql`CREATE INDEX IF NOT EXISTS idx_integration_configs_type ON integration_configs(type)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_integration_configs_status ON integration_configs(status)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_sync_history_integration ON integration_sync_history(integration_id)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_sync_history_status ON integration_sync_history(status, started_at)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_webhook_events_integration ON webhook_events(integration_id)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_webhook_events_processed ON webhook_events(processed, created_at)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_data_mapping_integration ON integration_data_mapping(integration_id)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_rate_limits_integration ON api_rate_limits(integration_id, endpoint)`;\n\n    console.log('✅ Third-party integration tables initialized successfully');\n  } catch (error) {\n    console.error('❌ Failed to initialize third-party integration tables:', error);\n  }\n}\n\n/**\n * Integration Manager - Central hub for all integrations\n */\nexport class IntegrationManager {\n  private static integrations = new Map<string, any>();\n\n  /**\n   * Register an integration\n   */\n  static registerIntegration(config: IntegrationConfig, implementation: any): void {\n    this.integrations.set(config.id, {\n      config,\n      implementation,\n      lastUsed: Date.now()\n    });\n  }\n\n  /**\n   * Get integration by ID\n   */\n  static getIntegration(integrationId: string): any {\n    const integration = this.integrations.get(integrationId);\n    if (integration) {\n      integration.lastUsed = Date.now();\n      return integration.implementation;\n    }\n    return null;\n  }\n\n  /**\n   * Create new integration configuration\n   */\n  static async createIntegration(config: Omit<IntegrationConfig, 'id' | 'created_at' | 'updated_at'>): Promise<string> {\n    try {\n      if (!sql) {\n        throw new Error('Database not available');\n      }\n\n      const result = await sql`\n        INSERT INTO integration_configs (\n          name, type, provider, status, credentials, settings, webhook_url\n        )\n        VALUES (\n          ${config.name}, ${config.type}, ${config.provider}, ${config.status},\n          ${JSON.stringify(config.credentials)}, ${JSON.stringify(config.settings)},\n          ${config.webhook_url || null}\n        )\n        RETURNING id\n      ` as Array<{ id: string }>;\n\n      return result[0].id;\n    } catch (error) {\n      console.error('Failed to create integration:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update integration configuration\n   */\n  static async updateIntegration(\n    integrationId: string, \n    updates: Partial<IntegrationConfig>\n  ): Promise<void> {\n    try {\n      if (!sql) {\n        throw new Error('Database not available');\n      }\n\n      const updateFields: string[] = [];\n      const updateValues: any[] = [];\n\n      Object.entries(updates).forEach(([key, value]) => {\n        if (key !== 'id' && key !== 'created_at' && value !== undefined) {\n          updateFields.push(`${key} = $${updateValues.length + 1}`);\n          updateValues.push(typeof value === 'object' ? JSON.stringify(value) : value);\n        }\n      });\n\n      if (updateFields.length > 0) {\n        updateFields.push('updated_at = NOW()');\n        \n        await sql`\n          UPDATE integration_configs \n          SET ${sql.unsafe(updateFields.join(', '))}\n          WHERE id = ${integrationId}\n        `;\n      }\n    } catch (error) {\n      console.error('Failed to update integration:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all integrations\n   */\n  static async getAllIntegrations(): Promise<IntegrationConfig[]> {\n    try {\n      if (!sql) {\n        return [];\n      }\n\n      const integrations = await sql`\n        SELECT * FROM integration_configs ORDER BY created_at DESC\n      ` as IntegrationConfig[];\n\n      return integrations;\n    } catch (error) {\n      console.error('Failed to get integrations:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Test integration connection\n   */\n  static async testIntegration(integrationId: string): Promise<{ success: boolean; error?: string }> {\n    try {\n      const integration = this.getIntegration(integrationId);\n      if (!integration) {\n        return { success: false, error: 'Integration not found' };\n      }\n\n      // Each integration should implement a test method\n      if (typeof integration.test === 'function') {\n        const result = await integration.test();\n        \n        // Update integration status based on test result\n        await this.updateIntegration(integrationId, {\n          status: result.success ? 'active' : 'error',\n          error_message: result.error || null,\n          last_sync: new Date().toISOString()\n        });\n\n        return result;\n      }\n\n      return { success: false, error: 'Test method not implemented' };\n    } catch (error) {\n      console.error('Integration test failed:', error);\n      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n    }\n  }\n\n  /**\n   * Record sync result\n   */\n  static async recordSyncResult(result: SyncResult): Promise<void> {\n    try {\n      if (!sql) {\n        console.warn('⚠️ Database not available, skipping sync result recording');\n        return;\n      }\n\n      await sql`\n        INSERT INTO integration_sync_history (\n          integration_id, sync_type, status, records_processed, \n          records_success, records_failed, error_details, \n          started_at, completed_at\n        )\n        VALUES (\n          ${result.integration_id}, ${result.sync_type}, ${result.status},\n          ${result.records_processed}, ${result.records_success}, ${result.records_failed},\n          ${result.error_details ? JSON.stringify(result.error_details) : null},\n          ${result.started_at}, ${result.completed_at}\n        )\n      `;\n    } catch (error) {\n      console.error('Failed to record sync result:', error);\n    }\n  }\n\n  /**\n   * Process webhook event\n   */\n  static async processWebhookEvent(event: Omit<WebhookEvent, 'id' | 'created_at'>): Promise<void> {\n    try {\n      if (!sql) {\n        console.warn('⚠️ Database not available, skipping webhook event processing');\n        return;\n      }\n\n      // Store webhook event\n      const result = await sql`\n        INSERT INTO webhook_events (\n          integration_id, event_type, payload, signature, retry_count\n        )\n        VALUES (\n          ${event.integration_id}, ${event.event_type}, \n          ${JSON.stringify(event.payload)}, ${event.signature || null}, ${event.retry_count}\n        )\n        RETURNING id\n      ` as Array<{ id: string }>;\n\n      const webhookId = result[0].id;\n\n      // Process the event\n      const integration = this.getIntegration(event.integration_id);\n      if (integration && typeof integration.processWebhook === 'function') {\n        try {\n          await integration.processWebhook(event.event_type, event.payload);\n          \n          // Mark as processed\n          await sql`\n            UPDATE webhook_events \n            SET processed = true, processed_at = NOW()\n            WHERE id = ${webhookId}\n          `;\n        } catch (processingError) {\n          // Mark as failed\n          await sql`\n            UPDATE webhook_events \n            SET error_message = ${processingError instanceof Error ? processingError.message : 'Processing failed'}\n            WHERE id = ${webhookId}\n          `;\n        }\n      }\n    } catch (error) {\n      console.error('Failed to process webhook event:', error);\n    }\n  }\n\n  /**\n   * Check API rate limits\n   */\n  static async checkRateLimit(\n    integrationId: string, \n    endpoint: string, \n    limit: number, \n    windowMinutes: number = 60\n  ): Promise<{ allowed: boolean; remaining: number; resetTime: Date }> {\n    try {\n      if (!sql) {\n        return { allowed: true, remaining: limit, resetTime: new Date() };\n      }\n\n      const now = new Date();\n      const windowStart = new Date(now.getTime() - windowMinutes * 60 * 1000);\n\n      // Get current rate limit status\n      const rateLimitData = await sql`\n        SELECT * FROM api_rate_limits \n        WHERE integration_id = ${integrationId} \n        AND endpoint = ${endpoint}\n        AND window_start > ${windowStart.toISOString()}\n      ` as Array<{\n        requests_made: number;\n        requests_limit: number;\n        window_start: string;\n        window_duration_minutes: number;\n      }>;\n\n      let requestsMade = 0;\n      let resetTime = new Date(now.getTime() + windowMinutes * 60 * 1000);\n\n      if (rateLimitData.length > 0) {\n        const data = rateLimitData[0];\n        requestsMade = data.requests_made;\n        resetTime = new Date(new Date(data.window_start).getTime() + data.window_duration_minutes * 60 * 1000);\n      }\n\n      const allowed = requestsMade < limit;\n      const remaining = Math.max(0, limit - requestsMade);\n\n      if (allowed) {\n        // Increment request count\n        await sql`\n          INSERT INTO api_rate_limits (\n            integration_id, endpoint, requests_made, requests_limit, \n            window_duration_minutes, last_request\n          )\n          VALUES (\n            ${integrationId}, ${endpoint}, 1, ${limit}, ${windowMinutes}, NOW()\n          )\n          ON CONFLICT (integration_id, endpoint) DO UPDATE SET\n            requests_made = CASE \n              WHEN api_rate_limits.window_start < ${windowStart.toISOString()} THEN 1\n              ELSE api_rate_limits.requests_made + 1\n            END,\n            window_start = CASE\n              WHEN api_rate_limits.window_start < ${windowStart.toISOString()} THEN NOW()\n              ELSE api_rate_limits.window_start\n            END,\n            last_request = NOW()\n        `;\n      }\n\n      return { allowed, remaining, resetTime };\n    } catch (error) {\n      console.error('Failed to check rate limit:', error);\n      return { allowed: true, remaining: limit, resetTime: new Date() };\n    }\n  }\n}\n\n/**\n * HubSpot CRM Integration\n */\nexport class HubSpotIntegration implements CRMIntegration {\n  private apiKey: string;\n  private baseUrl = 'https://api.hubapi.com';\n\n  constructor(apiKey: string) {\n    this.apiKey = apiKey;\n  }\n\n  async test(): Promise<{ success: boolean; error?: string }> {\n    try {\n      const response = await fetch(`${this.baseUrl}/contacts/v1/lists/all/contacts/all?count=1&hapikey=${this.apiKey}`);\n      return { success: response.ok };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Connection failed' };\n    }\n  }\n\n  async syncCustomers(): Promise<SyncResult> {\n    const startTime = new Date().toISOString();\n    let recordsProcessed = 0;\n    let recordsSuccess = 0;\n    let recordsFailed = 0;\n    const errorDetails: string[] = [];\n\n    try {\n      // Get customers from local database\n      if (sql) {\n        const customers = await sql`\n          SELECT id, email, first_name, last_name, phone, created_at\n          FROM users \n          WHERE email IS NOT NULL\n          LIMIT 100\n        ` as Array<{\n          id: string;\n          email: string;\n          first_name: string;\n          last_name: string;\n          phone: string;\n          created_at: string;\n        }>;\n\n        for (const customer of customers) {\n          recordsProcessed++;\n          \n          try {\n            const result = await this.createContact({\n              email: customer.email,\n              firstname: customer.first_name,\n              lastname: customer.last_name,\n              phone: customer.phone,\n              createdate: customer.created_at\n            });\n\n            if (result.success) {\n              recordsSuccess++;\n            } else {\n              recordsFailed++;\n              if (result.error) errorDetails.push(result.error);\n            }\n          } catch (error) {\n            recordsFailed++;\n            errorDetails.push(`Customer ${customer.email}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n          }\n        }\n      }\n\n      return {\n        integration_id: 'hubspot',\n        sync_type: 'full',\n        status: recordsFailed === 0 ? 'success' : (recordsSuccess > 0 ? 'partial' : 'failed'),\n        records_processed: recordsProcessed,\n        records_success: recordsSuccess,\n        records_failed: recordsFailed,\n        error_details: errorDetails.length > 0 ? errorDetails : undefined,\n        started_at: startTime,\n        completed_at: new Date().toISOString()\n      };\n    } catch (error) {\n      return {\n        integration_id: 'hubspot',\n        sync_type: 'full',\n        status: 'failed',\n        records_processed: recordsProcessed,\n        records_success: recordsSuccess,\n        records_failed: recordsFailed,\n        error_details: [error instanceof Error ? error.message : 'Sync failed'],\n        started_at: startTime,\n        completed_at: new Date().toISOString()\n      };\n    }\n  }\n\n  async syncOrders(): Promise<SyncResult> {\n    // Similar implementation for orders\n    return {\n      integration_id: 'hubspot',\n      sync_type: 'full',\n      status: 'success',\n      records_processed: 0,\n      records_success: 0,\n      records_failed: 0,\n      started_at: new Date().toISOString(),\n      completed_at: new Date().toISOString()\n    };\n  }\n\n  async createContact(customerData: any): Promise<{ success: boolean; id?: string; error?: string }> {\n    try {\n      const response = await fetch(`${this.baseUrl}/contacts/v1/contact?hapikey=${this.apiKey}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ properties: customerData })\n      });\n\n      if (response.ok) {\n        const result = await response.json();\n        return { success: true, id: result.vid?.toString() };\n      } else {\n        const error = await response.text();\n        return { success: false, error };\n      }\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n    }\n  }\n\n  async updateContact(contactId: string, data: any): Promise<{ success: boolean; error?: string }> {\n    try {\n      const response = await fetch(`${this.baseUrl}/contacts/v1/contact/vid/${contactId}/profile?hapikey=${this.apiKey}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ properties: data })\n      });\n\n      return { success: response.ok, error: response.ok ? undefined : await response.text() };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n    }\n  }\n\n  async createDeal(dealData: any): Promise<{ success: boolean; id?: string; error?: string }> {\n    try {\n      const response = await fetch(`${this.baseUrl}/deals/v1/deal?hapikey=${this.apiKey}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ properties: dealData })\n      });\n\n      if (response.ok) {\n        const result = await response.json();\n        return { success: true, id: result.dealId?.toString() };\n      } else {\n        const error = await response.text();\n        return { success: false, error };\n      }\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n    }\n  }\n\n  async getContacts(filters?: any): Promise<any[]> {\n    try {\n      const response = await fetch(`${this.baseUrl}/contacts/v1/lists/all/contacts/all?hapikey=${this.apiKey}`);\n      if (response.ok) {\n        const result = await response.json();\n        return result.contacts || [];\n      }\n      return [];\n    } catch (error) {\n      console.error('Failed to get contacts:', error);\n      return [];\n    }\n  }\n}\n\n/**\n * Twilio SMS Integration\n */\nexport class TwilioSMSIntegration implements SMSIntegration {\n  private accountSid: string;\n  private authToken: string;\n  private fromNumber: string;\n\n  constructor(accountSid: string, authToken: string, fromNumber: string) {\n    this.accountSid = accountSid;\n    this.authToken = authToken;\n    this.fromNumber = fromNumber;\n  }\n\n  async test(): Promise<{ success: boolean; error?: string }> {\n    try {\n      // Test by validating credentials with Twilio API\n      const auth = Buffer.from(`${this.accountSid}:${this.authToken}`).toString('base64');\n      const response = await fetch(`https://api.twilio.com/2010-04-01/Accounts/${this.accountSid}.json`, {\n        headers: { 'Authorization': `Basic ${auth}` }\n      });\n      \n      return { success: response.ok };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Connection failed' };\n    }\n  }\n\n  async sendSMS(to: string, message: string, metadata?: any): Promise<{ success: boolean; messageId?: string; error?: string }> {\n    try {\n      const auth = Buffer.from(`${this.accountSid}:${this.authToken}`).toString('base64');\n      \n      const response = await fetch(`https://api.twilio.com/2010-04-01/Accounts/${this.accountSid}/Messages.json`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Basic ${auth}`,\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: new URLSearchParams({\n          From: this.fromNumber,\n          To: to,\n          Body: message\n        })\n      });\n\n      if (response.ok) {\n        const result = await response.json();\n        return { success: true, messageId: result.sid };\n      } else {\n        const error = await response.text();\n        return { success: false, error };\n      }\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n    }\n  }\n\n  async sendBulkSMS(recipients: Array<{ phone: string; message: string }>): Promise<SyncResult> {\n    const startTime = new Date().toISOString();\n    let recordsProcessed = 0;\n    let recordsSuccess = 0;\n    let recordsFailed = 0;\n    const errorDetails: string[] = [];\n\n    for (const recipient of recipients) {\n      recordsProcessed++;\n      \n      try {\n        const result = await this.sendSMS(recipient.phone, recipient.message);\n        if (result.success) {\n          recordsSuccess++;\n        } else {\n          recordsFailed++;\n          if (result.error) errorDetails.push(`${recipient.phone}: ${result.error}`);\n        }\n      } catch (error) {\n        recordsFailed++;\n        errorDetails.push(`${recipient.phone}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      }\n    }\n\n    return {\n      integration_id: 'twilio',\n      sync_type: 'full',\n      status: recordsFailed === 0 ? 'success' : (recordsSuccess > 0 ? 'partial' : 'failed'),\n      records_processed: recordsProcessed,\n      records_success: recordsSuccess,\n      records_failed: recordsFailed,\n      error_details: errorDetails.length > 0 ? errorDetails : undefined,\n      started_at: startTime,\n      completed_at: new Date().toISOString()\n    };\n  }\n\n  async getDeliveryStatus(messageId: string): Promise<{ status: string; delivered_at?: string }> {\n    try {\n      const auth = Buffer.from(`${this.accountSid}:${this.authToken}`).toString('base64');\n      \n      const response = await fetch(`https://api.twilio.com/2010-04-01/Accounts/${this.accountSid}/Messages/${messageId}.json`, {\n        headers: { 'Authorization': `Basic ${auth}` }\n      });\n\n      if (response.ok) {\n        const result = await response.json();\n        return {\n          status: result.status,\n          delivered_at: result.date_sent\n        };\n      }\n      \n      return { status: 'unknown' };\n    } catch (error) {\n      console.error('Failed to get delivery status:', error);\n      return { status: 'error' };\n    }\n  }\n\n  async validatePhoneNumber(phone: string): Promise<{ valid: boolean; formatted?: string }> {\n    try {\n      const auth = Buffer.from(`${this.accountSid}:${this.authToken}`).toString('base64');\n      \n      const response = await fetch(`https://lookups.twilio.com/v1/PhoneNumbers/${encodeURIComponent(phone)}`, {\n        headers: { 'Authorization': `Basic ${auth}` }\n      });\n\n      if (response.ok) {\n        const result = await response.json();\n        return {\n          valid: true,\n          formatted: result.phone_number\n        };\n      }\n      \n      return { valid: false };\n    } catch (error) {\n      console.error('Failed to validate phone number:', error);\n      return { valid: false };\n    }\n  }\n}\n\n/**\n * Run integration health checks\n */\nexport async function runIntegrationHealthChecks(): Promise<void> {\n  try {\n    console.log('🔍 Running integration health checks...');\n\n    const integrations = await IntegrationManager.getAllIntegrations();\n    \n    for (const integration of integrations) {\n      if (integration.status === 'active') {\n        console.log(`Testing ${integration.name} (${integration.provider})...`);\n        \n        const testResult = await IntegrationManager.testIntegration(integration.id);\n        \n        if (testResult.success) {\n          console.log(`✅ ${integration.name} is healthy`);\n        } else {\n          console.log(`❌ ${integration.name} failed: ${testResult.error}`);\n        }\n      }\n    }\n\n    // Process pending webhook events\n    if (sql) {\n      const pendingWebhooks = await sql`\n        SELECT * FROM webhook_events \n        WHERE processed = false \n        AND retry_count < 3\n        ORDER BY created_at ASC\n        LIMIT 50\n      ` as WebhookEvent[];\n\n      for (const webhook of pendingWebhooks) {\n        try {\n          await IntegrationManager.processWebhookEvent({\n            integration_id: webhook.integration_id,\n            event_type: webhook.event_type,\n            payload: webhook.payload,\n            signature: webhook.signature,\n            processed: false,\n            retry_count: webhook.retry_count + 1\n          });\n        } catch (error) {\n          console.error(`Failed to process webhook ${webhook.id}:`, error);\n        }\n      }\n    }\n\n    console.log('✅ Integration health checks completed');\n  } catch (error) {\n    console.error('❌ Integration health checks failed:', error);\n  }\n}\n\n// Initialize third-party integration tables on module load\ninitializeThirdPartyIntegrationTables();\n\n// Run integration health checks every 30 minutes\nsetInterval(runIntegrationHealthChecks, 30 * 60 * 1000);","usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/AccountPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/AdminPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/B2BPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/BlogPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/BlogPostPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/CareersPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/CheckoutPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/ContactPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/HomePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/LabResultsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/LearnPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/LegalPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/LoginPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/NotFoundPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/OrderConfirmationPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/OrderTrackingPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/PasswordResetPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/PrivacyPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/RegisterPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/ResetPasswordPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/ShippingPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/ShopPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/TermsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/admin/ComplianceReports.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/legal/PrivacyPolicy.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/pages/legal/TermsOfService.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/AIService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/ComplianceService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/CustomerSegmentation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/EmailAutomation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/ListmonkService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/RecommendationEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/abandonedCartService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/activityService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/aiService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PredictiveAnalytics' is defined but never used.","line":22,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CacheManager' is defined but never used.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'HubSpotIntegration' is defined but never used.","line":36,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TwilioSMSIntegration' is defined but never used.","line":37,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IntegrationConfig' is defined but never used.","line":39,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SyncResult' is defined but never used.","line":40,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'customerId' is defined but never used.","line":566,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":566,"endColumn":52},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":574,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":574,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16951,16954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16951,16954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'customerId' is defined but never used.","line":589,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":589,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'weights' is assigned a value but never used.","line":611,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":611,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'conditions' is defined but never used.","line":774,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":774,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":775,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":775,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'triggerData' is defined but never used.","line":784,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":784,"endColumn":16}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AI Service - Unified AI and Advanced Analytics Orchestration\n * Integrates all Phase 4 advanced features into a cohesive AI-powered system\n */\n\nimport { \n  getProductRecommendations, \n  trackCustomerBehavior, \n  updatePersonalizationProfile,\n  getRecommendationAnalytics,\n  type RecommendationRequest,\n  type ProductRecommendation,\n  type CustomerBehavior\n} from '../lib/ai-recommendations';\n\nimport { \n  generateAnalyticsDashboard, \n  generatePredictiveAnalytics,\n  storeAnalyticsSnapshot,\n  updateRealTimeMetric,\n  type AnalyticsDashboard,\n  type PredictiveAnalytics\n} from '../lib/advanced-analytics';\n\nimport { \n  CacheManager, \n  QueryOptimizer, \n  HealthMonitor,\n  runPerformanceOptimization,\n  type PerformanceMetrics,\n  type SystemHealth\n} from '../lib/performance-optimization';\n\nimport { \n  IntegrationManager,\n  HubSpotIntegration,\n  TwilioSMSIntegration,\n  runIntegrationHealthChecks,\n  type IntegrationConfig,\n  type SyncResult\n} from '../lib/third-party-integrations';\n\nexport interface AIInsights {\n  customerInsights: {\n    personalizedRecommendations: ProductRecommendation[];\n    churnRisk: number;\n    lifetimeValuePrediction: number;\n    nextBestAction: string;\n    engagementScore: number;\n  };\n  businessInsights: {\n    revenueProjection: { nextMonth: number; confidence: number };\n    inventoryOptimization: Array<{ product_id: string; action: string; impact: number }>;\n    marketingOpportunities: string[];\n    operationalEfficiency: number;\n  };\n  systemInsights: {\n    performanceScore: number;\n    healthStatus: 'optimal' | 'good' | 'warning' | 'critical';\n    optimizationSuggestions: string[];\n    predictedLoad: number;\n  };\n}\n\nexport interface AIAutomationRule {\n  id: string;\n  name: string;\n  trigger: {\n    type: 'customer_behavior' | 'system_metric' | 'business_event' | 'time_based';\n    conditions: Record<string, unknown>;\n  };\n  actions: Array<{\n    type: 'send_email' | 'send_sms' | 'update_inventory' | 'create_promotion' | 'sync_crm';\n    parameters: Record<string, unknown>;\n  }>;\n  isActive: boolean;\n  lastTriggered?: string;\n  successRate: number;\n}\n\nexport interface SmartDashboard {\n  overview: AnalyticsDashboard;\n  aiInsights: AIInsights;\n  recommendations: {\n    immediate: Array<{ priority: 'high' | 'medium' | 'low'; action: string; impact: string }>;\n    strategic: Array<{ timeframe: string; action: string; expectedOutcome: string }>;\n  };\n  alerts: Array<{\n    type: 'performance' | 'business' | 'system' | 'security';\n    severity: 'info' | 'warning' | 'critical';\n    message: string;\n    actionRequired: boolean;\n    timestamp: string;\n  }>;\n  automationStatus: {\n    activeRules: number;\n    triggeredToday: number;\n    successRate: number;\n    nextScheduledActions: Array<{ action: string; scheduledFor: string }>;\n  };\n}\n\n/**\n * AI Service - Main orchestration class\n */\nexport class AIService {\n  private static instance: AIService;\n  private automationRules: Map<string, AIAutomationRule> = new Map();\n  private isInitialized = false;\n\n  private constructor() {}\n\n  static getInstance(): AIService {\n    if (!AIService.instance) {\n      AIService.instance = new AIService();\n    }\n    return AIService.instance;\n  }\n\n  /**\n   * Initialize AI Service with all subsystems\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      console.log('🤖 Initializing AI Service...');\n\n      // Initialize integrations\n      await this.initializeIntegrations();\n\n      // Set up automation rules\n      await this.setupDefaultAutomationRules();\n\n      // Start background processes\n      this.startBackgroundProcesses();\n\n      this.isInitialized = true;\n      console.log('✅ AI Service initialized successfully');\n    } catch (error) {\n      console.error('❌ Failed to initialize AI Service:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get comprehensive AI insights for a customer\n   */\n  async getCustomerAIInsights(customerId: string): Promise<AIInsights['customerInsights']> {\n    try {\n      // Get personalized recommendations\n      const recommendations = await getProductRecommendations({\n        customer_id: customerId,\n        recommendation_type: 'homepage',\n        limit: 10\n      });\n\n      // Get predictive analytics\n      const predictiveAnalytics = await generatePredictiveAnalytics();\n      \n      // Find customer in churn prediction\n      const customerChurn = predictiveAnalytics.customerChurnPrediction.find(\n        c => c.customer_id === customerId\n      );\n\n      // Calculate engagement score based on recent activity\n      const engagementScore = await this.calculateEngagementScore(customerId);\n\n      // Determine next best action\n      const nextBestAction = await this.determineNextBestAction(customerId, customerChurn, engagementScore);\n\n      return {\n        personalizedRecommendations: recommendations,\n        churnRisk: customerChurn?.churn_probability || 0,\n        lifetimeValuePrediction: await this.predictCustomerLifetimeValue(customerId),\n        nextBestAction,\n        engagementScore\n      };\n    } catch (error) {\n      console.error('Failed to get customer AI insights:', error);\n      return {\n        personalizedRecommendations: [],\n        churnRisk: 0,\n        lifetimeValuePrediction: 0,\n        nextBestAction: 'No action recommended',\n        engagementScore: 0\n      };\n    }\n  }\n\n  /**\n   * Get business intelligence insights\n   */\n  async getBusinessAIInsights(): Promise<AIInsights['businessInsights']> {\n    try {\n      const predictiveAnalytics = await generatePredictiveAnalytics();\n      \n      // Extract key insights\n      const revenueProjection = {\n        nextMonth: predictiveAnalytics.revenueProjection.next_month,\n        confidence: predictiveAnalytics.revenueProjection.confidence_score\n      };\n\n      const inventoryOptimization = predictiveAnalytics.inventoryOptimization.map(item => ({\n        product_id: item.product_id,\n        action: item.reorder_recommendation ? 'reorder' : 'reduce_stock',\n        impact: item.cost_impact\n      }));\n\n      const marketingOpportunities = await this.identifyMarketingOpportunities();\n      const operationalEfficiency = await this.calculateOperationalEfficiency();\n\n      return {\n        revenueProjection,\n        inventoryOptimization,\n        marketingOpportunities,\n        operationalEfficiency\n      };\n    } catch (error) {\n      console.error('Failed to get business AI insights:', error);\n      return {\n        revenueProjection: { nextMonth: 0, confidence: 0 },\n        inventoryOptimization: [],\n        marketingOpportunities: [],\n        operationalEfficiency: 0\n      };\n    }\n  }\n\n  /**\n   * Get system performance insights\n   */\n  async getSystemAIInsights(): Promise<AIInsights['systemInsights']> {\n    try {\n      const performanceMetrics = await HealthMonitor.getPerformanceMetrics();\n      const systemHealth = await HealthMonitor.performHealthCheck();\n      \n      // Calculate performance score (0-100)\n      const performanceScore = this.calculatePerformanceScore(performanceMetrics);\n      \n      // Determine health status\n      const healthStatus = this.mapHealthStatus(systemHealth.status);\n      \n      // Generate optimization suggestions\n      const optimizationSuggestions = await this.generateOptimizationSuggestions(performanceMetrics);\n      \n      // Predict system load\n      const predictedLoad = await this.predictSystemLoad();\n\n      return {\n        performanceScore,\n        healthStatus,\n        optimizationSuggestions,\n        predictedLoad\n      };\n    } catch (error) {\n      console.error('Failed to get system AI insights:', error);\n      return {\n        performanceScore: 0,\n        healthStatus: 'critical',\n        optimizationSuggestions: ['Unable to analyze system performance'],\n        predictedLoad: 0\n      };\n    }\n  }\n\n  /**\n   * Generate smart dashboard with AI-powered insights\n   */\n  async generateSmartDashboard(\n    startDate: string,\n    endDate: string\n  ): Promise<SmartDashboard> {\n    try {\n      // Get base analytics dashboard\n      const overview = await generateAnalyticsDashboard(startDate, endDate);\n\n      // Get AI insights\n      const aiInsights: AIInsights = {\n        customerInsights: await this.getAggregatedCustomerInsights(),\n        businessInsights: await this.getBusinessAIInsights(),\n        systemInsights: await this.getSystemAIInsights()\n      };\n\n      // Generate recommendations\n      const recommendations = await this.generateSmartRecommendations(overview, aiInsights);\n\n      // Get alerts\n      const alerts = await this.generateSmartAlerts(aiInsights);\n\n      // Get automation status\n      const automationStatus = await this.getAutomationStatus();\n\n      return {\n        overview,\n        aiInsights,\n        recommendations,\n        alerts,\n        automationStatus\n      };\n    } catch (error) {\n      console.error('Failed to generate smart dashboard:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Process customer behavior with AI analysis\n   */\n  async processCustomerBehaviorWithAI(behavior: Omit<CustomerBehavior, 'timestamp'>): Promise<void> {\n    try {\n      // Track the behavior\n      await trackCustomerBehavior(behavior);\n\n      // Update personalization profile\n      if (behavior.customer_id) {\n        await updatePersonalizationProfile(behavior.customer_id);\n      }\n\n      // Check for automation triggers\n      await this.checkAutomationTriggers('customer_behavior', behavior);\n\n      // Update real-time metrics\n      await updateRealTimeMetric('customer_activity', 1, 5); // 5-minute TTL\n    } catch (error) {\n      console.error('Failed to process customer behavior with AI:', error);\n    }\n  }\n\n  /**\n   * Execute AI-powered automation\n   */\n  async executeAutomation(ruleId: string, triggerData: Record<string, unknown>): Promise<void> {\n    try {\n      const rule = this.automationRules.get(ruleId);\n      if (!rule || !rule.isActive) {\n        return;\n      }\n\n      console.log(`🤖 Executing automation rule: ${rule.name}`);\n\n      for (const action of rule.actions) {\n        try {\n          await this.executeAutomationAction(action, triggerData);\n        } catch (actionError) {\n          console.error(`Failed to execute action ${action.type}:`, actionError);\n        }\n      }\n\n      // Update rule statistics\n      rule.lastTriggered = new Date().toISOString();\n      // In a real implementation, you'd update success rate based on action results\n    } catch (error) {\n      console.error('Failed to execute automation:', error);\n    }\n  }\n\n  /**\n   * Get AI-powered product recommendations with context\n   */\n  async getSmartRecommendations(\n    request: RecommendationRequest & { context?: Record<string, unknown> }\n  ): Promise<{\n    recommendations: ProductRecommendation[];\n    reasoning: string;\n    confidence: number;\n    alternatives: ProductRecommendation[];\n  }> {\n    try {\n      // Get base recommendations\n      const recommendations = await getProductRecommendations(request);\n\n      // Enhance with AI context\n      const reasoning = this.generateRecommendationReasoning(request, recommendations);\n      const confidence = this.calculateRecommendationConfidence(recommendations);\n\n      // Get alternative recommendations\n      const alternativeRequest = { ...request, limit: 5 };\n      if (request.customer_id) {\n        alternativeRequest.recommendation_type = 'personalized';\n      }\n      const alternatives = await getProductRecommendations(alternativeRequest);\n\n      return {\n        recommendations,\n        reasoning,\n        confidence,\n        alternatives: alternatives.filter(alt => \n          !recommendations.some(rec => rec.product_id === alt.product_id)\n        )\n      };\n    } catch (error) {\n      console.error('Failed to get smart recommendations:', error);\n      return {\n        recommendations: [],\n        reasoning: 'Unable to generate recommendations',\n        confidence: 0,\n        alternatives: []\n      };\n    }\n  }\n\n  /**\n   * Optimize system performance using AI\n   */\n  async optimizeSystemPerformance(): Promise<{\n    optimizationsApplied: string[];\n    performanceImprovement: number;\n    recommendations: string[];\n  }> {\n    try {\n      console.log('🚀 Running AI-powered system optimization...');\n\n      const beforeMetrics = await HealthMonitor.getPerformanceMetrics();\n      const optimizationsApplied: string[] = [];\n\n      // Run performance optimization\n      await runPerformanceOptimization();\n      optimizationsApplied.push('Cache cleanup and optimization');\n\n      // Optimize database queries\n      const queryAnalytics = await QueryOptimizer.getQueryAnalytics();\n      if (queryAnalytics.slowestQueries.length > 0) {\n        optimizationsApplied.push('Query performance analysis');\n      }\n\n      // Run integration health checks\n      await runIntegrationHealthChecks();\n      optimizationsApplied.push('Integration health verification');\n\n      // Get after metrics\n      const afterMetrics = await HealthMonitor.getPerformanceMetrics();\n      const performanceImprovement = this.calculatePerformanceImprovement(beforeMetrics, afterMetrics);\n\n      // Generate recommendations\n      const recommendations = await this.generateOptimizationSuggestions(afterMetrics);\n\n      console.log(`✅ System optimization completed. Performance improved by ${performanceImprovement}%`);\n\n      return {\n        optimizationsApplied,\n        performanceImprovement,\n        recommendations\n      };\n    } catch (error) {\n      console.error('Failed to optimize system performance:', error);\n      return {\n        optimizationsApplied: [],\n        performanceImprovement: 0,\n        recommendations: ['System optimization failed - manual intervention required']\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n\n  private async initializeIntegrations(): Promise<void> {\n    // Initialize default integrations (would be configured via environment variables)\n    const integrations = [\n      {\n        name: 'HubSpot CRM',\n        type: 'crm' as const,\n        provider: 'hubspot',\n        status: 'inactive' as const,\n        credentials: {},\n        settings: {}\n      },\n      {\n        name: 'Twilio SMS',\n        type: 'sms' as const,\n        provider: 'twilio',\n        status: 'inactive' as const,\n        credentials: {},\n        settings: {}\n      }\n    ];\n\n    for (const integration of integrations) {\n      try {\n        await IntegrationManager.createIntegration(integration);\n      } catch (error) {\n        console.warn(`Failed to initialize ${integration.name}:`, error);\n      }\n    }\n  }\n\n  private async setupDefaultAutomationRules(): Promise<void> {\n    const defaultRules: AIAutomationRule[] = [\n      {\n        id: 'abandoned_cart_recovery',\n        name: 'Abandoned Cart Recovery',\n        trigger: {\n          type: 'customer_behavior',\n          conditions: { event_type: 'cart_abandoned', time_threshold: 3600 }\n        },\n        actions: [\n          {\n            type: 'send_email',\n            parameters: { template: 'abandoned_cart', delay_minutes: 60 }\n          }\n        ],\n        isActive: true,\n        successRate: 0.25\n      },\n      {\n        id: 'high_value_customer_alert',\n        name: 'High Value Customer Alert',\n        trigger: {\n          type: 'business_event',\n          conditions: { order_value: { gt: 500 } }\n        },\n        actions: [\n          {\n            type: 'sync_crm',\n            parameters: { priority: 'high', tag: 'vip_customer' }\n          }\n        ],\n        isActive: true,\n        successRate: 0.95\n      },\n      {\n        id: 'low_inventory_alert',\n        name: 'Low Inventory Alert',\n        trigger: {\n          type: 'system_metric',\n          conditions: { inventory_level: { lt: 10 } }\n        },\n        actions: [\n          {\n            type: 'send_email',\n            parameters: { template: 'low_inventory', recipients: ['inventory@company.com'] }\n          }\n        ],\n        isActive: true,\n        successRate: 1.0\n      }\n    ];\n\n    defaultRules.forEach(rule => {\n      this.automationRules.set(rule.id, rule);\n    });\n  }\n\n  private startBackgroundProcesses(): void {\n    // Run AI insights update every 15 minutes\n    setInterval(async () => {\n      try {\n        await this.updateAIInsights();\n      } catch (error) {\n        console.error('Background AI insights update failed:', error);\n      }\n    }, 15 * 60 * 1000);\n\n    // Run automation checks every 5 minutes\n    setInterval(async () => {\n      try {\n        await this.processAutomationQueue();\n      } catch (error) {\n        console.error('Background automation processing failed:', error);\n      }\n    }, 5 * 60 * 1000);\n  }\n\n  private async calculateEngagementScore(customerId: string): Promise<number> {\n    // Simplified engagement score calculation\n    // In a real implementation, this would analyze multiple factors\n    return Math.random() * 100; // Placeholder\n  }\n\n  private async determineNextBestAction(\n    customerId: string, \n    churnData: any, \n    engagementScore: number\n  ): Promise<string> {\n    if (churnData && churnData.churn_probability > 0.7) {\n      return 'Send retention offer';\n    }\n    if (engagementScore < 30) {\n      return 'Send re-engagement campaign';\n    }\n    if (engagementScore > 80) {\n      return 'Offer loyalty program upgrade';\n    }\n    return 'Send personalized product recommendations';\n  }\n\n  private async predictCustomerLifetimeValue(customerId: string): Promise<number> {\n    // Simplified CLV prediction\n    // In a real implementation, this would use ML models\n    return Math.random() * 1000; // Placeholder\n  }\n\n  private async identifyMarketingOpportunities(): Promise<string[]> {\n    return [\n      'Launch seasonal promotion campaign',\n      'Target high-value customer segment',\n      'Implement referral program',\n      'Optimize email send times'\n    ];\n  }\n\n  private async calculateOperationalEfficiency(): Promise<number> {\n    // Calculate based on various operational metrics\n    return Math.random() * 100; // Placeholder\n  }\n\n  private calculatePerformanceScore(metrics: PerformanceMetrics): number {\n    // Weighted performance score calculation\n    const weights = {\n      responseTime: 0.3,\n      cacheHitRate: 0.2,\n      errorRate: 0.2,\n      throughput: 0.15,\n      databaseQueryTime: 0.15\n    };\n\n    let score = 100;\n    \n    // Penalize based on metrics (simplified)\n    if (metrics.responseTime > 1000) score -= 20;\n    if (metrics.cacheHitRate < 70) score -= 15;\n    if (metrics.errorRate > 1) score -= 25;\n    if (metrics.databaseQueryTime > 500) score -= 10;\n\n    return Math.max(0, Math.min(100, score));\n  }\n\n  private mapHealthStatus(status: SystemHealth['status']): AIInsights['systemInsights']['healthStatus'] {\n    const mapping = {\n      'healthy': 'optimal' as const,\n      'warning': 'warning' as const,\n      'critical': 'critical' as const\n    };\n    return mapping[status] || 'good';\n  }\n\n  private async generateOptimizationSuggestions(metrics: PerformanceMetrics): Promise<string[]> {\n    const suggestions: string[] = [];\n\n    if (metrics.responseTime > 1000) {\n      suggestions.push('Optimize slow API endpoints');\n    }\n    if (metrics.cacheHitRate < 70) {\n      suggestions.push('Improve caching strategy');\n    }\n    if (metrics.errorRate > 1) {\n      suggestions.push('Investigate and fix error sources');\n    }\n    if (metrics.databaseQueryTime > 500) {\n      suggestions.push('Optimize database queries and indexes');\n    }\n\n    return suggestions;\n  }\n\n  private async predictSystemLoad(): Promise<number> {\n    // Predict system load based on historical patterns\n    return Math.random() * 100; // Placeholder\n  }\n\n  private async getAggregatedCustomerInsights(): Promise<AIInsights['customerInsights']> {\n    // Return aggregated insights across all customers\n    return {\n      personalizedRecommendations: [],\n      churnRisk: 15, // 15% average churn risk\n      lifetimeValuePrediction: 250, // Average CLV\n      nextBestAction: 'Implement personalization strategy',\n      engagementScore: 65 // Average engagement score\n    };\n  }\n\n  private async generateSmartRecommendations(\n    overview: AnalyticsDashboard, \n    insights: AIInsights\n  ): Promise<SmartDashboard['recommendations']> {\n    const immediate = [];\n    const strategic = [];\n\n    // Generate immediate recommendations based on current state\n    if (insights.systemInsights.performanceScore < 70) {\n      immediate.push({\n        priority: 'high' as const,\n        action: 'Optimize system performance',\n        impact: 'Improve user experience and reduce churn'\n      });\n    }\n\n    if (overview.realTimeMetrics.cartAbandonment > 70) {\n      immediate.push({\n        priority: 'high' as const,\n        action: 'Implement cart abandonment recovery',\n        impact: 'Recover 15-25% of abandoned carts'\n      });\n    }\n\n    // Generate strategic recommendations\n    strategic.push({\n      timeframe: '1-3 months',\n      action: 'Implement AI-powered personalization',\n      expectedOutcome: '20-30% increase in conversion rate'\n    });\n\n    strategic.push({\n      timeframe: '3-6 months',\n      action: 'Launch predictive inventory management',\n      expectedOutcome: '15% reduction in inventory costs'\n    });\n\n    return { immediate, strategic };\n  }\n\n  private async generateSmartAlerts(insights: AIInsights): Promise<SmartDashboard['alerts']> {\n    const alerts = [];\n\n    if (insights.systemInsights.healthStatus === 'critical') {\n      alerts.push({\n        type: 'system' as const,\n        severity: 'critical' as const,\n        message: 'System health is critical - immediate attention required',\n        actionRequired: true,\n        timestamp: new Date().toISOString()\n      });\n    }\n\n    if (insights.businessInsights.revenueProjection.confidence < 0.5) {\n      alerts.push({\n        type: 'business' as const,\n        severity: 'warning' as const,\n        message: 'Revenue projection confidence is low - review business metrics',\n        actionRequired: false,\n        timestamp: new Date().toISOString()\n      });\n    }\n\n    return alerts;\n  }\n\n  private async getAutomationStatus(): Promise<SmartDashboard['automationStatus']> {\n    const activeRules = Array.from(this.automationRules.values()).filter(rule => rule.isActive).length;\n    const triggeredToday = 0; // Would calculate from actual data\n    const successRate = Array.from(this.automationRules.values())\n      .reduce((sum, rule) => sum + rule.successRate, 0) / this.automationRules.size;\n\n    return {\n      activeRules,\n      triggeredToday,\n      successRate: Math.round(successRate * 100),\n      nextScheduledActions: [\n        { action: 'Daily analytics report', scheduledFor: 'Tomorrow 9:00 AM' },\n        { action: 'Weekly inventory optimization', scheduledFor: 'Monday 6:00 AM' }\n      ]\n    };\n  }\n\n  private async checkAutomationTriggers(\n    triggerType: string, \n    data: Record<string, unknown>\n  ): Promise<void> {\n    for (const [ruleId, rule] of this.automationRules.entries()) {\n      if (rule.isActive && rule.trigger.type === triggerType) {\n        // Check if conditions are met (simplified)\n        const shouldTrigger = this.evaluateTriggerConditions(rule.trigger.conditions, data);\n        \n        if (shouldTrigger) {\n          await this.executeAutomation(ruleId, data);\n        }\n      }\n    }\n  }\n\n  private evaluateTriggerConditions(\n    conditions: Record<string, unknown>, \n    data: Record<string, unknown>\n  ): boolean {\n    // Simplified condition evaluation\n    // In a real implementation, this would be more sophisticated\n    return Math.random() > 0.8; // 20% chance to trigger for demo\n  }\n\n  private async executeAutomationAction(\n    action: AIAutomationRule['actions'][0], \n    triggerData: Record<string, unknown>\n  ): Promise<void> {\n    switch (action.type) {\n      case 'send_email':\n        console.log(`📧 Sending email with template: ${action.parameters.template}`);\n        break;\n      case 'send_sms':\n        console.log(`📱 Sending SMS: ${action.parameters.message}`);\n        break;\n      case 'sync_crm':\n        console.log(`🔄 Syncing to CRM with priority: ${action.parameters.priority}`);\n        break;\n      case 'update_inventory':\n        console.log(`📦 Updating inventory for product: ${action.parameters.product_id}`);\n        break;\n      case 'create_promotion':\n        console.log(`🎁 Creating promotion: ${action.parameters.name}`);\n        break;\n    }\n  }\n\n  private generateRecommendationReasoning(\n    request: RecommendationRequest, \n    recommendations: ProductRecommendation[]\n  ): string {\n    if (recommendations.length === 0) {\n      return 'No suitable recommendations found based on current criteria';\n    }\n\n    const types = [...new Set(recommendations.map(r => r.recommendation_type))];\n    return `Generated ${recommendations.length} recommendations based on ${types.join(', ')} analysis`;\n  }\n\n  private calculateRecommendationConfidence(recommendations: ProductRecommendation[]): number {\n    if (recommendations.length === 0) return 0;\n    \n    const avgConfidence = recommendations.reduce((sum, rec) => sum + rec.confidence_score, 0) / recommendations.length;\n    return Math.round(avgConfidence * 100);\n  }\n\n  private calculatePerformanceImprovement(\n    before: PerformanceMetrics, \n    after: PerformanceMetrics\n  ): number {\n    // Calculate improvement percentage (simplified)\n    const beforeScore = this.calculatePerformanceScore(before);\n    const afterScore = this.calculatePerformanceScore(after);\n    \n    return Math.round(((afterScore - beforeScore) / beforeScore) * 100);\n  }\n\n  private async updateAIInsights(): Promise<void> {\n    try {\n      // Update recommendation analytics\n      const recAnalytics = await getRecommendationAnalytics();\n      await storeAnalyticsSnapshot('ai', 'recommendation_performance', recAnalytics.totalRecommendations);\n\n      // Update system performance metrics\n      const perfMetrics = await HealthMonitor.getPerformanceMetrics();\n      await storeAnalyticsSnapshot('system', 'performance_score', this.calculatePerformanceScore(perfMetrics));\n\n      console.log('✅ AI insights updated');\n    } catch (error) {\n      console.error('Failed to update AI insights:', error);\n    }\n  }\n\n  private async processAutomationQueue(): Promise<void> {\n    // Process any queued automation tasks\n    console.log('🔄 Processing automation queue...');\n  }\n}\n\n// Export singleton instance\nexport const aiService = AIService.getInstance();","usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/authService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'password_hash' is assigned a value but never used.","line":111,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'failed_login_attempts' is assigned a value but never used.","line":111,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'locked_until' is assigned a value but never used.","line":111,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":65}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { sql } from '../lib/neon';\nimport { \n  hashPassword, \n  verifyPassword, \n  generateToken, \n  generateRefreshToken, \n  generateVerificationToken,\n  verifyToken,\n  isValidEmail,\n  validatePassword,\n  checkRateLimit,\n  logAuthEvent,\n  initializeAuthTables,\n  type User,\n  type AuthResult\n} from '../lib/auth';\nimport { emailService } from './emailService';\n\n// Initialize auth tables on service load\ninitializeAuthTables();\n\nexport const authService = {\n  async login(email: string, password: string, ipAddress: string = '', userAgent: string = ''): Promise<AuthResult> {\n    try {\n      // Rate limiting\n      if (!checkRateLimit(`login_${email}`, 5, 15 * 60 * 1000)) {\n        await logAuthEvent(null, 'login_failed', ipAddress, userAgent, { reason: 'rate_limited', email });\n        return { success: false, error: 'Too many login attempts. Please try again in 15 minutes.' };\n      }\n\n      // Validate email format\n      if (!isValidEmail(email)) {\n        return { success: false, error: 'Invalid email format' };\n      }\n\n      if (!sql) {\n        console.warn('⚠️ Database not available');\n        return { success: false, error: 'Service temporarily unavailable' };\n      }\n\n      // Get user from database\n      const users = await sql`\n        SELECT id, email, password_hash, first_name, last_name, phone, role, email_verified, \n               failed_login_attempts, locked_until, created_at, updated_at\n        FROM users \n        WHERE email = ${email.toLowerCase()}\n      ` as Array<User & { password_hash: string; failed_login_attempts: number; locked_until: string | null }>;\n      \n      if (users.length === 0) {\n        await logAuthEvent(null, 'login_failed', ipAddress, userAgent, { reason: 'user_not_found', email });\n        return { success: false, error: 'Invalid email or password' };\n      }\n      \n      const user = users[0];\n\n      // Check if account is locked\n      if (user.locked_until && new Date(user.locked_until) > new Date()) {\n        await logAuthEvent(user.id, 'login_failed', ipAddress, userAgent, { reason: 'account_locked' });\n        return { success: false, error: 'Account is temporarily locked. Please try again later.' };\n      }\n\n      // Verify password\n      const isValidPassword = await verifyPassword(password, user.password_hash);\n      \n      if (!isValidPassword) {\n        // Increment failed attempts\n        const newFailedAttempts = (user.failed_login_attempts || 0) + 1;\n        const lockUntil = newFailedAttempts >= 5 ? new Date(Date.now() + 30 * 60 * 1000) : null; // Lock for 30 minutes after 5 failed attempts\n\n        await sql`\n          UPDATE users \n          SET failed_login_attempts = ${newFailedAttempts}, \n              locked_until = ${lockUntil?.toISOString() || null}\n          WHERE id = ${user.id}\n        `;\n\n        await logAuthEvent(user.id, 'login_failed', ipAddress, userAgent, { \n          reason: 'invalid_password', \n          failed_attempts: newFailedAttempts \n        });\n\n        return { success: false, error: 'Invalid email or password' };\n      }\n\n      // Check if email is verified\n      if (!user.email_verified) {\n        return { success: false, error: 'Please verify your email address before logging in' };\n      }\n\n      // Reset failed attempts on successful login\n      await sql`\n        UPDATE users \n        SET failed_login_attempts = 0, locked_until = NULL, last_login = NOW()\n        WHERE id = ${user.id}\n      `;\n\n      // Generate tokens\n      const token = generateToken(user);\n      const refreshToken = generateRefreshToken(user.id);\n\n      // Store refresh token in database\n      await sql`\n        INSERT INTO refresh_tokens (user_id, token, expires_at)\n        VALUES (${user.id}, ${refreshToken}, ${new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()})\n      `;\n\n      // Log successful login\n      await logAuthEvent(user.id, 'login_success', ipAddress, userAgent);\n\n      // Remove sensitive data\n      const { password_hash, failed_login_attempts, locked_until, ...safeUser } = user;\n\n      return { \n        success: true, \n        user: safeUser,\n        token,\n        refreshToken\n      };\n    } catch (error) {\n      console.error('Login error:', error);\n      return { success: false, error: 'Login failed. Please try again.' };\n    }\n  },\n\n  async register(\n    email: string, \n    password: string, \n    firstName: string,\n    lastName: string,\n    phone?: string,\n    ipAddress: string = '',\n    userAgent: string = ''\n  ): Promise<AuthResult> {\n    try {\n      // Rate limiting for registration\n      if (!checkRateLimit(`register_${ipAddress}`, 3, 60 * 60 * 1000)) {\n        return { success: false, error: 'Too many registration attempts. Please try again in 1 hour.' };\n      }\n\n      // Validate input\n      if (!isValidEmail(email)) {\n        return { success: false, error: 'Invalid email format' };\n      }\n\n      const passwordValidation = validatePassword(password);\n      if (!passwordValidation.isValid) {\n        return { success: false, error: passwordValidation.errors.join(', ') };\n      }\n\n      if (!firstName.trim() || !lastName.trim()) {\n        return { success: false, error: 'First name and last name are required' };\n      }\n\n      if (!sql) {\n        console.warn('⚠️ Database not available');\n        return { success: false, error: 'Service temporarily unavailable' };\n      }\n\n      // Check if user already exists\n      const existingUsers = await sql`\n        SELECT id FROM users WHERE email = ${email.toLowerCase()}\n      `;\n\n      if (existingUsers.length > 0) {\n        return { success: false, error: 'An account with this email already exists' };\n      }\n\n      // Hash password\n      const passwordHash = await hashPassword(password);\n\n      // Generate verification token\n      const verificationToken = generateVerificationToken();\n\n      // Create user\n      const users = await sql`\n        INSERT INTO users (email, password_hash, first_name, last_name, phone, role, email_verified)\n        VALUES (${email.toLowerCase()}, ${passwordHash}, ${firstName.trim()}, ${lastName.trim()}, ${phone || null}, 'customer', false)\n        RETURNING id, email, first_name, last_name, phone, role, email_verified, created_at, updated_at\n      ` as Array<User>;\n\n      if (users.length === 0) {\n        return { success: false, error: 'Failed to create account' };\n      }\n\n      const user = users[0];\n\n      // Store verification token\n      await sql`\n        INSERT INTO email_verification_tokens (user_id, token, expires_at)\n        VALUES (${user.id}, ${verificationToken}, ${new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()})\n      `;\n\n      // Send verification email\n      try {\n        await emailService.sendVerificationEmail(user.email, user.first_name || 'User', verificationToken);\n      } catch (emailError) {\n        console.error('Failed to send verification email:', emailError);\n        // Don't fail registration if email fails\n      }\n\n      // Log registration\n      await logAuthEvent(user.id, 'login_success', ipAddress, userAgent, { event: 'registration' });\n\n      return { \n        success: true, \n        user,\n        error: 'Account created successfully. Please check your email to verify your account.'\n      };\n    } catch (error) {\n      console.error('Registration error:', error);\n      return { success: false, error: 'Registration failed. Please try again.' };\n    }\n  },\n\n  async logout(token: string, ipAddress: string = '', userAgent: string = ''): Promise<{ success: boolean }> {\n    try {\n      const decoded = verifyToken(token);\n      if (decoded) {\n        // Revoke refresh token\n        if (sql) {\n          await sql`\n            UPDATE refresh_tokens \n            SET revoked_at = NOW() \n            WHERE user_id = ${decoded.userId} AND revoked_at IS NULL\n          `;\n        }\n\n        // Log logout\n        await logAuthEvent(decoded.userId, 'logout', ipAddress, userAgent);\n      }\n\n      return { success: true };\n    } catch (error) {\n      console.error('Logout error:', error);\n      return { success: true }; // Always return success for logout\n    }\n  },\n\n  async getCurrentUser(token: string): Promise<User | null> {\n    try {\n      const decoded = verifyToken(token);\n      if (!decoded) {\n        return null;\n      }\n\n      if (!sql) {\n        console.warn('⚠️ Database not available');\n        return null;\n      }\n\n      const users = await sql`\n        SELECT id, email, first_name, last_name, phone, role, email_verified, created_at, updated_at\n        FROM users \n        WHERE id = ${decoded.userId}\n      ` as Array<User>;\n      \n      return users.length > 0 ? users[0] : null;\n    } catch (error) {\n      console.error('Get current user error:', error);\n      return null;\n    }\n  },\n\n  async refreshToken(refreshToken: string): Promise<AuthResult> {\n    try {\n      if (!sql) {\n        return { success: false, error: 'Service temporarily unavailable' };\n      }\n\n      // Verify refresh token\n      const tokenRecords = await sql`\n        SELECT rt.user_id, rt.expires_at, u.email, u.first_name, u.last_name, u.phone, u.role, u.email_verified, u.created_at, u.updated_at\n        FROM refresh_tokens rt\n        JOIN users u ON rt.user_id = u.id\n        WHERE rt.token = ${refreshToken} AND rt.revoked_at IS NULL\n      ` as Array<{ user_id: string; expires_at: string } & User>;\n\n      if (tokenRecords.length === 0) {\n        return { success: false, error: 'Invalid refresh token' };\n      }\n\n      const record = tokenRecords[0];\n\n      // Check if token is expired\n      if (new Date(record.expires_at) < new Date()) {\n        return { success: false, error: 'Refresh token expired' };\n      }\n\n      // Generate new tokens\n      const user: User = {\n        id: record.user_id,\n        email: record.email,\n        first_name: record.first_name,\n        last_name: record.last_name,\n        phone: record.phone,\n        role: record.role,\n        email_verified: record.email_verified,\n        created_at: record.created_at,\n        updated_at: record.updated_at\n      };\n\n      const newToken = generateToken(user);\n      const newRefreshToken = generateRefreshToken(user.id);\n\n      // Revoke old refresh token and create new one\n      await sql`\n        UPDATE refresh_tokens \n        SET revoked_at = NOW() \n        WHERE token = ${refreshToken}\n      `;\n\n      await sql`\n        INSERT INTO refresh_tokens (user_id, token, expires_at)\n        VALUES (${user.id}, ${newRefreshToken}, ${new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()})\n      `;\n\n      return {\n        success: true,\n        user,\n        token: newToken,\n        refreshToken: newRefreshToken\n      };\n    } catch (error) {\n      console.error('Refresh token error:', error);\n      return { success: false, error: 'Failed to refresh token' };\n    }\n  },\n\n  async verifyEmail(token: string): Promise<{ success: boolean; error?: string }> {\n    try {\n      if (!sql) {\n        return { success: false, error: 'Service temporarily unavailable' };\n      }\n\n      // Find verification token\n      const tokenRecords = await sql`\n        SELECT user_id, expires_at, used_at\n        FROM email_verification_tokens\n        WHERE token = ${token}\n      ` as Array<{ user_id: string; expires_at: string; used_at: string | null }>;\n\n      if (tokenRecords.length === 0) {\n        return { success: false, error: 'Invalid verification token' };\n      }\n\n      const record = tokenRecords[0];\n\n      // Check if token is already used\n      if (record.used_at) {\n        return { success: false, error: 'Verification token already used' };\n      }\n\n      // Check if token is expired\n      if (new Date(record.expires_at) < new Date()) {\n        return { success: false, error: 'Verification token expired' };\n      }\n\n      // Mark user as verified and token as used\n      await sql`\n        UPDATE users \n        SET email_verified = true \n        WHERE id = ${record.user_id}\n      `;\n\n      await sql`\n        UPDATE email_verification_tokens \n        SET used_at = NOW() \n        WHERE token = ${token}\n      `;\n\n      // Log email verification\n      await logAuthEvent(record.user_id, 'email_verified', '', '');\n\n      return { success: true };\n    } catch (error) {\n      console.error('Email verification error:', error);\n      return { success: false, error: 'Email verification failed' };\n    }\n  },\n\n  async requestPasswordReset(email: string, ipAddress: string = '', userAgent: string = ''): Promise<{ success: boolean; error?: string }> {\n    try {\n      // Rate limiting\n      if (!checkRateLimit(`password_reset_${email}`, 3, 60 * 60 * 1000)) {\n        return { success: false, error: 'Too many password reset attempts. Please try again in 1 hour.' };\n      }\n\n      if (!isValidEmail(email)) {\n        return { success: false, error: 'Invalid email format' };\n      }\n\n      if (!sql) {\n        return { success: false, error: 'Service temporarily unavailable' };\n      }\n\n      // Check if user exists\n      const users = await sql`\n        SELECT id, first_name, email_verified\n        FROM users \n        WHERE email = ${email.toLowerCase()}\n      ` as Array<{ id: string; first_name: string; email_verified: boolean }>;\n\n      // Always return success to prevent email enumeration\n      if (users.length === 0) {\n        return { success: true };\n      }\n\n      const user = users[0];\n\n      // Only send reset email if account is verified\n      if (!user.email_verified) {\n        return { success: true };\n      }\n\n      // Generate reset token\n      const resetToken = generateVerificationToken();\n\n      // Store reset token\n      await sql`\n        INSERT INTO password_reset_tokens (user_id, token, expires_at)\n        VALUES (${user.id}, ${resetToken}, ${new Date(Date.now() + 60 * 60 * 1000).toISOString()})\n      `;\n\n      // Send reset email\n      try {\n        const resetUrl = `${import.meta.env.VITE_APP_URL || 'https://rise-via.vercel.app'}/reset-password?token=${resetToken}`;\n        \n        await emailService.sendEmail(\n          email,\n          'Password Reset Request',\n          `\n            <h1>Password Reset Request</h1>\n            <p>Hi ${user.first_name},</p>\n            <p>You requested a password reset for your Rise Via account.</p>\n            <p>Click the link below to reset your password:</p>\n            <a href=\"${resetUrl}\" style=\"background: #7c3aed; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; display: inline-block;\">\n              Reset Password\n            </a>\n            <p>This link will expire in 1 hour.</p>\n            <p>If you didn't request this reset, you can safely ignore this email.</p>\n            <p>The Rise Via Team</p>\n          `\n        );\n      } catch (emailError) {\n        console.error('Failed to send password reset email:', emailError);\n      }\n\n      // Log password reset request\n      await logAuthEvent(user.id, 'password_reset', ipAddress, userAgent, { event: 'request' });\n\n      return { success: true };\n    } catch (error) {\n      console.error('Password reset request error:', error);\n      return { success: false, error: 'Password reset request failed' };\n    }\n  },\n\n  async resetPassword(token: string, newPassword: string, ipAddress: string = '', userAgent: string = ''): Promise<{ success: boolean; error?: string }> {\n    try {\n      // Validate password\n      const passwordValidation = validatePassword(newPassword);\n      if (!passwordValidation.isValid) {\n        return { success: false, error: passwordValidation.errors.join(', ') };\n      }\n\n      if (!sql) {\n        return { success: false, error: 'Service temporarily unavailable' };\n      }\n\n      // Find reset token\n      const tokenRecords = await sql`\n        SELECT user_id, expires_at, used_at\n        FROM password_reset_tokens\n        WHERE token = ${token}\n      ` as Array<{ user_id: string; expires_at: string; used_at: string | null }>;\n\n      if (tokenRecords.length === 0) {\n        return { success: false, error: 'Invalid reset token' };\n      }\n\n      const record = tokenRecords[0];\n\n      // Check if token is already used\n      if (record.used_at) {\n        return { success: false, error: 'Reset token already used' };\n      }\n\n      // Check if token is expired\n      if (new Date(record.expires_at) < new Date()) {\n        return { success: false, error: 'Reset token expired' };\n      }\n\n      // Hash new password\n      const passwordHash = await hashPassword(newPassword);\n\n      // Update password and mark token as used\n      await sql`\n        UPDATE users \n        SET password_hash = ${passwordHash}, failed_login_attempts = 0, locked_until = NULL\n        WHERE id = ${record.user_id}\n      `;\n\n      await sql`\n        UPDATE password_reset_tokens \n        SET used_at = NOW() \n        WHERE token = ${token}\n      `;\n\n      // Revoke all refresh tokens for this user\n      await sql`\n        UPDATE refresh_tokens \n        SET revoked_at = NOW() \n        WHERE user_id = ${record.user_id} AND revoked_at IS NULL\n      `;\n\n      // Log password reset\n      await logAuthEvent(record.user_id, 'password_reset', ipAddress, userAgent, { event: 'completed' });\n\n      return { success: true };\n    } catch (error) {\n      console.error('Password reset error:', error);\n      return { success: false, error: 'Password reset failed' };\n    }\n  },\n\n  async resendVerificationEmail(email: string): Promise<{ success: boolean; error?: string }> {\n    try {\n      if (!isValidEmail(email)) {\n        return { success: false, error: 'Invalid email format' };\n      }\n\n      if (!sql) {\n        return { success: false, error: 'Service temporarily unavailable' };\n      }\n\n      // Check if user exists and is not verified\n      const users = await sql`\n        SELECT id, first_name, email_verified\n        FROM users \n        WHERE email = ${email.toLowerCase()}\n      ` as Array<{ id: string; first_name: string; email_verified: boolean }>;\n\n      if (users.length === 0) {\n        return { success: false, error: 'User not found' };\n      }\n\n      const user = users[0];\n\n      if (user.email_verified) {\n        return { success: false, error: 'Email is already verified' };\n      }\n\n      // Generate new verification token\n      const verificationToken = generateVerificationToken();\n\n      // Store verification token\n      await sql`\n        INSERT INTO email_verification_tokens (user_id, token, expires_at)\n        VALUES (${user.id}, ${verificationToken}, ${new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()})\n      `;\n\n      // Send verification email\n      await emailService.sendVerificationEmail(email, user.first_name || 'User', verificationToken);\n\n      return { success: true };\n    } catch (error) {\n      console.error('Resend verification email error:', error);\n      return { success: false, error: 'Failed to resend verification email' };\n    }\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/blogScheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/blogService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/cloudinaryService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/couponService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/customerService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/emailService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/marketingService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createCustomerSegment' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getSegmentInsights' is defined but never used.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'awardPoints' is defined but never used.","line":21,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'redeemPoints' is defined but never used.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'validateCouponCode' is defined but never used.","line":28,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createPromotion' is defined but never used.","line":29,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createCouponCode' is defined but never used.","line":30,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createPriceAlert' is defined but never used.","line":32,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":19}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Marketing Service\n * Orchestrates all marketing and customer experience features\n */\n\nimport { \n  triggerEmailAutomation,\n  subscribeToEmails,\n  createEmailTemplate,\n  getEmailAnalytics\n} from '../lib/email-automation';\nimport { \n  updateCustomerAnalytics,\n  createCustomerSegment,\n  getSegmentCustomers,\n  getSegmentInsights,\n  updateAllSegmentMemberships\n} from '../lib/customer-segmentation';\nimport { \n  getCustomerLoyalty,\n  awardPoints,\n  redeemPoints,\n  getAvailableRewards,\n  getLoyaltyAnalytics\n} from '../lib/loyalty-system';\nimport { \n  applyPromotionsToCart,\n  validateCouponCode,\n  createPromotion,\n  createCouponCode,\n  trackAbandonedCart,\n  createPriceAlert,\n  getPromotionAnalytics\n} from '../lib/promotions';\n\nexport interface MarketingDashboard {\n  emailMarketing: {\n    totalSent: number;\n    openRate: number;\n    clickRate: number;\n    subscribers: number;\n  };\n  customerSegmentation: {\n    totalSegments: number;\n    totalCustomers: number;\n    topSegments: Array<{ name: string; size: number; revenue: number }>;\n  };\n  loyaltyProgram: {\n    totalMembers: number;\n    pointsIssued: number;\n    pointsRedeemed: number;\n    tierDistribution: Array<{ tier: string; count: number }>;\n  };\n  promotions: {\n    activePromotions: number;\n    totalDiscountGiven: number;\n    conversionRate: number;\n    topCoupons: Array<{ code: string; usage: number }>;\n  };\n}\n\nexport class MarketingService {\n  /**\n   * Get comprehensive marketing dashboard data\n   */\n  async getMarketingDashboard(\n    startDate: string = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),\n    endDate: string = new Date().toISOString()\n  ): Promise<MarketingDashboard> {\n    try {\n      // Get email analytics\n      const emailAnalytics = await getEmailAnalytics(startDate, endDate);\n      \n      // Get loyalty analytics\n      const loyaltyAnalytics = await getLoyaltyAnalytics();\n      \n      // Get promotion analytics\n      const promotionAnalytics = await getPromotionAnalytics(startDate, endDate);\n\n      return {\n        emailMarketing: {\n          totalSent: emailAnalytics.totalSent,\n          openRate: emailAnalytics.openRate,\n          clickRate: emailAnalytics.clickRate,\n          subscribers: 0 // Would need to query email_subscribers table\n        },\n        customerSegmentation: {\n          totalSegments: 0, // Would need to query customer_segments table\n          totalCustomers: 0, // Would need to query customer_analytics table\n          topSegments: []\n        },\n        loyaltyProgram: {\n          totalMembers: loyaltyAnalytics.totalMembers,\n          pointsIssued: loyaltyAnalytics.totalPointsIssued,\n          pointsRedeemed: loyaltyAnalytics.totalPointsRedeemed,\n          tierDistribution: loyaltyAnalytics.tierDistribution\n        },\n        promotions: {\n          activePromotions: promotionAnalytics.activePromotions,\n          totalDiscountGiven: promotionAnalytics.totalDiscountGiven,\n          conversionRate: promotionAnalytics.conversionRate,\n          topCoupons: []\n        }\n      };\n    } catch (error) {\n      console.error('Failed to get marketing dashboard:', error);\n      return {\n        emailMarketing: { totalSent: 0, openRate: 0, clickRate: 0, subscribers: 0 },\n        customerSegmentation: { totalSegments: 0, totalCustomers: 0, topSegments: [] },\n        loyaltyProgram: { totalMembers: 0, pointsIssued: 0, pointsRedeemed: 0, tierDistribution: [] },\n        promotions: { activePromotions: 0, totalDiscountGiven: 0, conversionRate: 0, topCoupons: [] }\n      };\n    }\n  }\n\n  /**\n   * Process customer journey events\n   */\n  async processCustomerEvent(\n    eventType: 'user_registered' | 'order_placed' | 'product_viewed' | 'cart_abandoned' | 'email_opened',\n    customerId: string,\n    eventData: Record<string, unknown> = {}\n  ): Promise<void> {\n    try {\n      // Update customer analytics\n      await updateCustomerAnalytics(customerId);\n\n      // Trigger appropriate email automations\n      const customerEmail = eventData.email as string;\n      if (customerEmail) {\n        await triggerEmailAutomation(eventType, customerEmail, eventData);\n      }\n\n      // Handle specific event types\n      switch (eventType) {\n        case 'user_registered':\n          // Subscribe to email list\n          if (customerEmail) {\n            await subscribeToEmails(\n              customerEmail,\n              eventData.firstName as string,\n              eventData.lastName as string,\n              'registration'\n            );\n          }\n          break;\n\n        case 'order_placed':\n          // This is handled in orderService.ts\n          break;\n\n        case 'cart_abandoned':\n          // Track abandoned cart\n          if (eventData.sessionId && eventData.cartItems) {\n            await trackAbandonedCart(\n              eventData.sessionId as string,\n              eventData.cartItems as Array<{\n                product_id: string;\n                product_name: string;\n                quantity: number;\n                price: number;\n                image_url?: string;\n              }>,\n              customerId,\n              customerEmail\n            );\n          }\n          break;\n      }\n    } catch (error) {\n      console.error('Failed to process customer event:', error);\n    }\n  }\n\n  /**\n   * Create targeted marketing campaign\n   */\n  async createTargetedCampaign(\n    campaignName: string,\n    segmentId: string,\n    templateId: string,\n    scheduledFor?: string\n  ): Promise<{ success: boolean; error?: string; campaignId?: string }> {\n    try {\n      // Get segment customers\n      const customers = await getSegmentCustomers(segmentId, 1000); // Limit to 1000 for now\n      \n      if (customers.length === 0) {\n        return { success: false, error: 'No customers found in segment' };\n      }\n\n      // For each customer, trigger the email automation\n      for (const customer of customers) {\n        if (scheduledFor) {\n          // Schedule for later (would need job queue in production)\n          setTimeout(async () => {\n            await triggerEmailAutomation('custom', customer.email, {\n              firstName: customer.first_name || 'Valued Customer',\n              customerId: customer.customer_id\n            });\n          }, new Date(scheduledFor).getTime() - Date.now());\n        } else {\n          // Send immediately\n          await triggerEmailAutomation('custom', customer.email, {\n            firstName: customer.first_name || 'Valued Customer',\n            customerId: customer.customer_id\n          });\n        }\n      }\n\n      return { \n        success: true, \n        campaignId: `campaign_${Date.now()}` // Would be a real ID in production\n      };\n    } catch (error) {\n      console.error('Failed to create targeted campaign:', error);\n      return { success: false, error: 'Failed to create campaign' };\n    }\n  }\n\n  /**\n   * Smart cart recommendations\n   */\n  async getCartRecommendations(\n    customerId: string,\n    cartItems: Array<{ product_id: string; category: string; price: number }>\n  ): Promise<{\n    promotions: Array<{\n      promotion_id: string;\n      name: string;\n      description: string;\n      discount_amount: number;\n      coupon_code?: string;\n    }>;\n    loyaltyRewards: Array<{\n      reward_id: string;\n      name: string;\n      points_required: number;\n      discount_value: number;\n    }>;\n    recommendations: Array<{\n      type: 'cross_sell' | 'upsell' | 'loyalty_bonus';\n      message: string;\n      action?: string;\n    }>;\n  }> {\n    try {\n      // Get applicable promotions\n      const promotionResult = await applyPromotionsToCart(\n        cartItems.map(item => ({\n          product_id: item.product_id,\n          product_name: 'Product', // Would get from product service\n          category: item.category,\n          quantity: 1,\n          price: item.price\n        })),\n        customerId\n      );\n\n      // Get customer loyalty status\n      const loyalty = await getCustomerLoyalty(customerId);\n      const availableRewards = loyalty ? await getAvailableRewards(customerId) : [];\n\n      // Generate smart recommendations\n      const recommendations: Array<{\n        type: 'cross_sell' | 'upsell' | 'loyalty_bonus';\n        message: string;\n        action?: string;\n      }> = [];\n\n      // Loyalty-based recommendations\n      if (loyalty) {\n        if (loyalty.points_to_next_tier && loyalty.points_to_next_tier <= 100) {\n          recommendations.push({\n            type: 'loyalty_bonus',\n            message: `You're only ${loyalty.points_to_next_tier} points away from ${loyalty.next_tier} tier!`,\n            action: 'Add more items to reach the next tier'\n          });\n        }\n\n        if (availableRewards.length > 0) {\n          recommendations.push({\n            type: 'loyalty_bonus',\n            message: `You have ${loyalty.current_points} points available for rewards!`,\n            action: 'View available rewards'\n          });\n        }\n      }\n\n      // Promotion-based recommendations\n      if (promotionResult.appliedPromotions.length === 0) {\n        recommendations.push({\n          type: 'upsell',\n          message: 'Add $25 more to qualify for free shipping!',\n          action: 'Browse more products'\n        });\n      }\n\n      return {\n        promotions: promotionResult.appliedPromotions.map(p => ({\n          promotion_id: p.promotion.id,\n          name: p.promotion.name,\n          description: p.promotion.description,\n          discount_amount: p.discount_amount,\n          coupon_code: p.coupon_code\n        })),\n        loyaltyRewards: availableRewards.slice(0, 3).map(r => ({\n          reward_id: r.id,\n          name: r.name,\n          points_required: r.points_required,\n          discount_value: r.reward_value\n        })),\n        recommendations\n      };\n    } catch (error) {\n      console.error('Failed to get cart recommendations:', error);\n      return { promotions: [], loyaltyRewards: [], recommendations: [] };\n    }\n  }\n\n  /**\n   * Customer lifecycle automation\n   */\n  async setupCustomerLifecycleAutomation(): Promise<void> {\n    try {\n      // Create welcome series templates\n      await createEmailTemplate(\n        'Welcome Email 1',\n        'Welcome to Rise Via! 🌿',\n        `\n          <h1>Welcome to Rise Via!</h1>\n          <p>Hi {{firstName}},</p>\n          <p>Welcome to the Rise Via family! We're excited to have you join our community of cannabis enthusiasts.</p>\n          <p>Here's what you can expect:</p>\n          <ul>\n            <li>Premium quality products</li>\n            <li>Fast, discreet delivery</li>\n            <li>Exclusive member benefits</li>\n            <li>Expert customer support</li>\n          </ul>\n          <p>As a welcome gift, enjoy 10% off your first order with code: WELCOME10</p>\n          <a href=\"{{shopUrl}}\" style=\"background: #7c3aed; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; display: inline-block;\">\n            Start Shopping\n          </a>\n          <p>Happy exploring!</p>\n          <p>The Rise Via Team</p>\n        `,\n        'Welcome to Rise Via! We\\'re excited to have you join our community.',\n        'welcome',\n        ['firstName', 'shopUrl']\n      );\n\n      // Create abandoned cart templates\n      await createEmailTemplate(\n        'Abandoned Cart Recovery',\n        'Don\\'t forget your items! 🛒',\n        `\n          <h1>You left something behind!</h1>\n          <p>Hi {{firstName}},</p>\n          <p>We noticed you left some great items in your cart. Don't worry, we saved them for you!</p>\n          <div style=\"border: 1px solid #e5e7eb; padding: 20px; margin: 20px 0; border-radius: 8px;\">\n            <h3>Your Cart Items:</h3>\n            {{cartItems}}\n            <p><strong>Total: ${{cartTotal}}</strong></p>\n          </div>\n          <p>Complete your purchase now and get 10% off with code: {{recoveryCode}}</p>\n          <a href=\"{{recoveryUrl}}\" style=\"background: #7c3aed; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; display: inline-block;\">\n            Complete Your Order\n          </a>\n          <p>This offer expires in 7 days.</p>\n          <p>The Rise Via Team</p>\n        `,\n        'Complete your purchase and save 10%!',\n        'abandoned_cart',\n        ['firstName', 'cartItems', 'cartTotal', 'recoveryCode', 'recoveryUrl']\n      );\n\n      // Create loyalty milestone template\n      await createEmailTemplate(\n        'Loyalty Tier Upgrade',\n        'Congratulations! You\\'ve reached {{newTier}} status! 🎉',\n        `\n          <h1>Congratulations, {{firstName}}!</h1>\n          <p>You've just reached <strong>{{newTier}}</strong> status in our loyalty program!</p>\n          <p>As a {{newTier}} member, you now enjoy:</p>\n          <div style=\"background: #f3f4f6; padding: 20px; margin: 20px 0; border-radius: 8px;\">\n            {{benefits}}\n          </div>\n          <p>Plus, we've added {{bonusPoints}} bonus points to your account!</p>\n          <a href=\"{{loyaltyUrl}}\" style=\"background: #7c3aed; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; display: inline-block;\">\n            View Your Benefits\n          </a>\n          <p>Thank you for being a valued member!</p>\n          <p>The Rise Via Team</p>\n        `,\n        'You\\'ve reached a new loyalty tier with exclusive benefits!',\n        'loyalty_milestone',\n        ['firstName', 'newTier', 'benefits', 'bonusPoints', 'loyaltyUrl']\n      );\n\n      console.log('✅ Customer lifecycle automation templates created');\n    } catch (error) {\n      console.error('Failed to setup customer lifecycle automation:', error);\n    }\n  }\n\n  /**\n   * Run daily marketing tasks\n   */\n  async runDailyMarketingTasks(): Promise<void> {\n    try {\n      console.log('🚀 Running daily marketing tasks...');\n\n      // Update all customer segment memberships\n      await updateAllSegmentMemberships();\n      console.log('✅ Updated customer segment memberships');\n\n      // This would also include:\n      // - Processing abandoned cart recovery (handled in promotions.ts)\n      // - Checking price alerts (handled in promotions.ts)\n      // - Expiring old loyalty points (handled in loyalty-system.ts)\n      // - Generating marketing reports\n      // - Cleaning up old email logs\n\n      console.log('✅ Daily marketing tasks completed');\n    } catch (error) {\n      console.error('Failed to run daily marketing tasks:', error);\n    }\n  }\n}\n\n// Export singleton instance\nexport const marketingService = new MarketingService();\n\n// Setup lifecycle automation on module load\nmarketingService.setupCustomerLifecycleAutomation();\n\n// Run daily tasks (in production, this would be handled by a job scheduler)\nsetInterval(() => {\n  marketingService.runDailyMarketingTasks();\n}, 24 * 60 * 60 * 1000); // Every 24 hours","usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/membershipService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/orderService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/paymentService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/payments/Aeropay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/payments/Hypur.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/payments/POSaBIT.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/payments/PaymentProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/payments/Stripe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/popupService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/priceAlertsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/priceTracking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/productService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/reviewService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/searchService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/wholesalePricingService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/services/wishlistService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/test-setup.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_params' is defined but never used.","line":17,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":47,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[579,582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[579,582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2133,2136],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2133,2136],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/test-utils.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"This rule can't verify that `export *` only exports components.","line":9,"column":1,"nodeType":"ExportAllDeclaration","messageId":"exportAll","endLine":9,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","line":20,"column":10,"nodeType":"Identifier","messageId":"localComponents","endLine":20,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/types/cart.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/types/database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/types/env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/types/payment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/types/product.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/types/reviews.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/types/wishlist.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/aiCompliance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/compliance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/cookies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/errorHandling.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/imageOptimization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/performance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/stateBlocking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/stateRestrictions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/utils/taxCalculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/tests/e2e/admin-operations.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/tests/e2e/age-verification.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/tests/e2e/cart-functionality.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/tests/e2e/purchase-flow.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/tests/e2e/search-functionality.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/tests/e2e/state-blocking.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/utils/mockStorage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/vite.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/project/Rise-Via/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]